<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Invariant Models · Invariant Models</title><meta name="title" content="Invariant Models · Invariant Models"/><meta property="og:title" content="Invariant Models · Invariant Models"/><meta property="twitter:title" content="Invariant Models · Invariant Models"/><meta name="description" content="Documentation for Invariant Models."/><meta property="og:description" content="Documentation for Invariant Models."/><meta property="twitter:description" content="Documentation for Invariant Models."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Invariant Models</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Invariant Models</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Invariance"><span>Invariance</span></a></li><li><a class="tocitem" href="#Case-Study-of-a-Minimal-Forced-System"><span>Case Study of a Minimal Forced System</span></a></li><li><a class="tocitem" href="#ROM-identification-from-data"><span>ROM identification from data</span></a></li><li><a class="tocitem" href="#Functional-Representation"><span>Functional Representation</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Invariant Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Invariant Models</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rs1909/InvariantModels" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rs1909/InvariantModels/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Invariant-Models"><a class="docs-heading-anchor" href="#Invariant-Models">Invariant Models</a><a id="Invariant-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Models" title="Permalink"></a></h1><p>This package is an improved version of <a href="https://github.com/rs1909/FMA">FMA</a>. Current capabilities are</p><ul><li>Identifies <strong>invariant foliations</strong> in autonomous, periodic and quasi-periodic systems from <strong>data</strong>.</li><li>Calculates invariant manifolds in autonomous, periodic and quasi-periodic systems from discrete-time systems and vector fields.</li><li>Calculates invariant foliations in autonomous, periodic and quasi-periodic systems from discrete-time systems and vector fields.</li><li>Calculates instantaneous frequencies and damping ratios on two-dimensional invariant manifolds.</li></ul><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>The system in question is assumed to obey the discrete-time map</p><p class="math-container">\[\begin{aligned}
\boldsymbol{x}_{k+1} &amp;=\boldsymbol{F}\left(\boldsymbol{x}_{k},\boldsymbol{\theta}_{k}\right)\\\boldsymbol{\theta}_{k+1} &amp;= \boldsymbol{\theta}_{k}+\boldsymbol{\omega} \Delta t,
\end{aligned} \tag{MAP}\]</p><p>where it is assumed that <span>$\Delta t$</span> is the sampling period, that is the duration of time between two samples <span>$\boldsymbol{x}_k$</span> and <span>$\boldsymbol{x}_{k+1}$</span>. or the vector field</p><p class="math-container">\[\begin{aligned}
\dot{\boldsymbol{x}} &amp;=\boldsymbol{F}\left(\boldsymbol{x},\boldsymbol{\theta}\right)\\\dot{\boldsymbol{\theta}} &amp;= \boldsymbol{\omega},
\end{aligned}  \tag{ODE}\]</p><p>It may be the case that variable <span>$\boldsymbol{\theta}$</span> is absent and therefore the system is autonomous.</p><h2 id="Invariance"><a class="docs-heading-anchor" href="#Invariance">Invariance</a><a id="Invariance-1"></a><a class="docs-heading-anchor-permalink" href="#Invariance" title="Permalink"></a></h2><p>There are four ways to connect a low-order model <span>$\boldsymbol{R}$</span> to <span>$\boldsymbol{F}$</span>. The figure below shows the four combinations. Only invariant foliations and invariant manifolds produce meaningful reduced order models. Only invariant foliations and autoencoders can be fitted to data. The intersection is invariant foliations. </p><p><img src="connections.svg" alt/></p><p>Therefore, </p><ul><li>when a <strong>system of equations</strong> is given, invariant manifolds are the most appropriate (foliations are still possible),</li><li>when <strong>data</strong> is given, only invariant foliations are appropriate.</li></ul><p>Autoencoders such as <a href="https://github.com/haller-group/SSMLearn">SSMLearn</a> do not enforce invariance and therefore generate spurious results as shown in <strong><a href="https://doi.org/10.1007/s00332-023-09932-y">Data-Driven Reduced Order Models Using Invariant Foliations, Manifolds and Autoencoders</a></strong>.</p><h3 id="Invariant-Foliations"><a class="docs-heading-anchor" href="#Invariant-Foliations">Invariant Foliations</a><a id="Invariant-Foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Foliations" title="Permalink"></a></h3><p>The invariance equation for foliations is</p><p class="math-container">\[\boldsymbol{R}\left(\boldsymbol{U}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) = \boldsymbol{U}\left(\boldsymbol{F}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}+\boldsymbol{\omega}\right) \tag{FOIL}\]</p><h3 id="Invariant-Manifolds"><a class="docs-heading-anchor" href="#Invariant-Manifolds">Invariant Manifolds</a><a id="Invariant-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Manifolds" title="Permalink"></a></h3><p>The invariance equation for manifolds is</p><p class="math-container">\[\boldsymbol{S}\left(\boldsymbol{V}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) = \boldsymbol{V}\left(\boldsymbol{F}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}+\boldsymbol{\omega}\right) \tag{MAN}\]</p><h2 id="Case-Study-of-a-Minimal-Forced-System"><a class="docs-heading-anchor" href="#Case-Study-of-a-Minimal-Forced-System">Case Study of a Minimal Forced System</a><a id="Case-Study-of-a-Minimal-Forced-System-1"></a><a class="docs-heading-anchor-permalink" href="#Case-Study-of-a-Minimal-Forced-System" title="Permalink"></a></h2><p>We consider a forced version of the Shaw-Pierre example, that originally appeared in [].</p><p class="math-container">\[\begin{aligned}
    \dot{x}_1 &amp;= x_3 \\
    \dot{x}_2 &amp;= x_4 \\
    \dot{x}_3 &amp;= - c x_3 - k x_1 - \kappa y_1^3 + k (x_2 - x_1) + c (x_4 - x_3) + p \cos(\theta+0.1) \\
    \dot{x}_4 &amp;= - c x_4 - k x_2 - k (x_2 - x_1) - c (x_4 - x_3) + p \cos(\theta) \\
    \dot{\theta} &amp;= \omega \\
\end{aligned}\]</p><p>The parameters are <span>$k=1$</span>, <span>$\kappa = 0.2$</span>, <span>$c = 2^{-5}$</span>. The forcing frequency is <span>$\omega = 1.2$</span> and the the forcing amplitude is <span>$p=0.25$</span>.</p><p>Without forcing the natural frequencies are approximately <span>$\omega_1 = 1$</span>, <span>$\omega_2 = \sqrt{3}$</span>. The damping ratios are <span>$\zeta_1 = 0.01561$</span> and <span>$\zeta_2 = 0.02705$</span>. The spectral quotient for the first mode is <span>$\beth_1 = 3$</span> and for the second mode is <span>$\beth_2 = 1$</span>. When forcing is turned on these values change slightly due to nonlinearity.</p><h3 id="Set-up"><a class="docs-heading-anchor" href="#Set-up">Set-up</a><a id="Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up" title="Permalink"></a></h3><p>First we import the required packages</p><pre><code class="language-julia hljs">using InvariantModels
using GLMakie</code></pre><p>Consider the Shaw-Pierre vector field</p><pre><code class="language-julia hljs">NDIM = 4

function shawpierre!(x, y, p, t)
    k = 1.0
    kappa = 0.2
    c = 2^-5

    x[1] = y[3]
    x[2] = y[4]
    x[3] = - c*y[3] - k*y[1] - kappa*y[1]^3 + k*(y[2]-y[1]) + c*(y[4]-y[3]) + p * cos(t+0.1)
    x[4] = - c*y[4] - k*y[2] - k*(y[2]-y[1]) - c*(y[4]-y[3]) + p * cos(t)
    return x
end

function shawpierre(z, p, t)
    dz = zero(z)
    return shawpierre!(dz, z, p, t)
end</code></pre><p>Set up some system parameters</p><pre><code class="language-julia hljs">Amplitude = 0.25        # forcing amplitude
omega_ode = 1.2         # forcing frequency

# parameters of the numerical method
fourier_order = 3       # fourier harmonics to be resolved
ODE_order = 7           # polynomial order of the calculations
SEL = [1 2]             # which invariant vector bundle to use
dispMaxAmp = 1.0        # maximum amplitude to display</code></pre><h3 id="Invariant-Manifolds-of-Vector-Fields"><a class="docs-heading-anchor" href="#Invariant-Manifolds-of-Vector-Fields">Invariant Manifolds of Vector Fields</a><a id="Invariant-Manifolds-of-Vector-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Manifolds-of-Vector-Fields" title="Permalink"></a></h3><p>Create a polynomial <code>MPode</code>, <code>XPode</code> out of our vector field</p><pre><code class="language-julia hljs">MPode = QPPolynomial(NDIM, NDIM, fourier_order, 0, ODE_order)
XPode = fromFunction(MPode, (x, t) -&gt; shawpierre(x, Amplitude, t))</code></pre><p>The invariant manifold can now be calculated using <a href="#InvariantModels.QPODETorusManifold"><code>QPODETorusManifold</code></a>:</p><pre><code class="language-julia hljs">MK, XK, MSn, XSn, MWn, XWn, _, _, XWre, oeva = QPODETorusManifold(MPode, XPode, omega_ode, SEL, threshold=0.1, resonance=false)</code></pre><p>The frequencies and damping ratios are extracted from the reduced order model using <a href="#InvariantModels.ODEFrequencyDamping"><code>ODEFrequencyDamping</code></a></p><pre><code class="language-julia hljs">That_ode, Rhat_ode, rho_ode, gamma_ode = ODEFrequencyDamping(MWn, XWn, MSn, XSn, dispMaxAmp)
odeAmp = range(0, dispMaxAmp, length=1000)
odeFreq = abs.(That_ode.(odeAmp))
odeDamp = -Rhat_ode.(odeAmp) ./ odeFreq</code></pre><p>The results are then plotted</p><pre><code class="language-julia hljs">fig = Figure(size=(1200, 400))
axFreq = Axis(fig[1, 1])
axDamp = Axis(fig[1, 2])
axFreq.xlabel = &quot;Frequency&quot;
axFreq.ylabel = &quot;Amplitude&quot;
axDamp.xlabel = &quot;Damping ratio&quot;
axDamp.ylabel = &quot;Amplitude&quot;

lines!(axFreq, odeFreq, odeAmp, label=&quot;ODE O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dash, linewidth=2)
lines!(axDamp, odeDamp, odeAmp, label=&quot;ODE O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dash, linewidth=2)
display(fig)</code></pre><p><img src="fig-data-shawpierre-2p-8.0-SIMAMP1.0-AMP0.25-F3-R7-U7-V7-S7-MODE1-ODE.svg" alt/></p><h3 id="Invariant-Manifolds-of-Maps"><a class="docs-heading-anchor" href="#Invariant-Manifolds-of-Maps">Invariant Manifolds of Maps</a><a id="Invariant-Manifolds-of-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Manifolds-of-Maps" title="Permalink"></a></h3><p>First we set up some additional parameters, such as the sampling period <span>$\Delta t$</span> = <code>Tstep</code></p><pre><code class="language-julia hljs">Tstep = 0.8                 # sampling period
omega = omega_ode * Tstep   # shift angle</code></pre><p>We now create a discrete-time map from the vector field by Taylor expanding an ODE solver about the origin using <a href="#InvariantModels.mapFromODE"><code>mapFromODE</code></a>. We take 500 time steps on the interval <span>$[\theta,\theta + \Delta t]$</span>. The resulting map <code>MP</code>, <code>XPmap</code> is dependent on the phase variable <span>$\theta \in [0,2\pi)$</span></p><pre><code class="language-julia hljs">MP = QPPolynomial(NDIM, NDIM, fourier_order, 0, ODE_order)
XPmap = zero(MP)
mapFromODE(MP, XPmap, shawpierre!, Amplitude, omega_ode, Tstep / 500, Tstep)</code></pre><p>The invariant manifold of the map is calculated using <a href="#InvariantModels.QPMAPTorusManifold"><code>QPMAPTorusManifold</code></a></p><pre><code class="language-julia hljs">MK, XK, MSn, XSn, MWn, XWn, MSd, XSd = QPMAPTorusManifold(MP, XPmap, omega, SEL, threshold = 0.1, resonance = false)</code></pre><p>The frequencies and damping ratios are extracted from the reduced order model using <a href="#InvariantModels.MAPFrequencyDamping"><code>MAPFrequencyDamping</code></a></p><pre><code class="language-julia hljs">That, Rhat_r, rho, gamma = MAPFrequencyDamping(MWn, XWn, MSn, XSn, dispMaxAmp)
mapAmp = range(0, dispMaxAmp, length=1000)
mapFreq = abs.(That.(mapAmp)) ./ Tstep
mapDamp = -log.(abs.(Rhat_r.(mapAmp))) ./ abs.(That.(mapAmp))</code></pre><p>The results are plotted</p><pre><code class="language-julia hljs">lines!(axFreq, mapFreq, mapAmp, label=&quot;MAP O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dashdot, linewidth=2)
lines!(axDamp, mapDamp, mapAmp, label=&quot;MAP O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dashdot, linewidth=2)
display(fig)</code></pre><p><img src="fig-data-shawpierre-2p-8.0-SIMAMP1.0-AMP0.25-F3-R7-U7-V7-S7-MODE1-MAP.svg" alt/></p><h3 id="Invariant-Foliations-of-Maps"><a class="docs-heading-anchor" href="#Invariant-Foliations-of-Maps">Invariant Foliations of Maps</a><a id="Invariant-Foliations-of-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Foliations-of-Maps" title="Permalink"></a></h3><p>Using <a href="#InvariantModels.QPGraphStyleFoliations"><code>QPGraphStyleFoliations</code></a>, two invariant foliations are calculated and the invariant manifold defined by the zero level-set of the second foliation is extracted.</p><pre><code class="language-julia hljs">MRf, XRf, MW, XW, MRt, XRt, MUt, XUt, MSt, XSt, MVt, XVt = QPGraphStyleFoliations(MP, XPmap, omega, SEL; dataScale=1, resonance=false, threshold=0.1)</code></pre><p>The results are plotted</p><pre><code class="language-julia hljs">MWf, XWf = toFourier(MW, XW)
That, Rhat_r, rho, gamma = MAPFrequencyDamping(MWf, XWf, MRf, XRf, dispMaxAmp)
foilAmp = range(0, dispMaxAmp, length=1000)
foilFreq = abs.(That.(foilAmp)) ./ Tstep
foilDamp = -log.(abs.(Rhat_r.(foilAmp))) ./ abs.(That.(foilAmp))

lines!(axFreq, foilFreq, foilAmp, label=&quot;FOIL O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dashdot, linewidth=2)
lines!(axDamp, foilDamp, foilAmp, label=&quot;FOIL O($(ODE_order)) A=$(Amplitude)&quot;, linestyle=:dashdot, linewidth=2)
display(fig)</code></pre><p><img src="fig-data-shawpierre-2p-8.0-SIMAMP1.0-AMP0.25-F3-R7-U7-V7-S7-MODE1-FOIL.svg" alt/></p><h2 id="ROM-identification-from-data"><a class="docs-heading-anchor" href="#ROM-identification-from-data">ROM identification from data</a><a id="ROM-identification-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#ROM-identification-from-data" title="Permalink"></a></h2><h3 id="Set-up-2"><a class="docs-heading-anchor" href="#Set-up-2">Set-up</a><a class="docs-heading-anchor-permalink" href="#Set-up-2" title="Permalink"></a></h3><p>Importing a library to load/store data and specifying parameters</p><pre><code class="language-julia hljs">using BSON: @load, @save
# parameters for the data-driven part
maxSimAmp = 1.0     # maximum initial condition measured from the torus
maxAmp = 1.0        # filter out data with amplitude greater than maxAmp
dataRatio = 1.0     # the proportion of data to be retained when filtering (all of it)
R_order = 7         # polynomial order of R
U_order = 7         # polynomial order of U
V_order = 7         # polynomial order of V
S_order = 7         # polynomial order of S
STEPS = 800         # number of optimisation steps to use

# the names of data files
revision = &quot;shawpierre-2p$(log2(scale_epsilon))-SIMAMP$(maxSimAmp)-AMP$(Amplitude)-F$(fourier_order)-R$(R_order)-U$(U_order)-V$(V_order)-S$(S_order)-MODE$(SEL[1])&quot;
datarevision = &quot;shawpierre-SIMAMP$(maxSimAmp)-AMP$(Amplitude)-F$(fourier_order)&quot;</code></pre><h3 id="Creating-data"><a class="docs-heading-anchor" href="#Creating-data">Creating data</a><a id="Creating-data-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-data" title="Permalink"></a></h3><p>We create 600 trajectories 60 points long each using <a href="#InvariantModels.generate"><code>generate</code></a> and save the data for future use.</p><pre><code class="language-julia hljs">dataX, dataY, thetaX, thetaY, thetaNIX, thetaNIY = generate(NDIM, shawpierre!, ones(NDIM) * maxSimAmp, 600, 50, fourier_order, omega_ode, Tstep, Amplitude, XWre)
@save &quot;data-$(datarevision).bson&quot; dataX dataY thetaX thetaY Tstep</code></pre><h3 id="Finding-an-Approximate-Linear-Model"><a class="docs-heading-anchor" href="#Finding-an-Approximate-Linear-Model">Finding an Approximate Linear Model</a><a id="Finding-an-Approximate-Linear-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-an-Approximate-Linear-Model" title="Permalink"></a></h3><p>An approximate linear model is found about the invariant torus using <a href="#InvariantModels.findLinearModel"><code>findLinearModel</code></a>.</p><pre><code class="language-julia hljs">A, b, MK1, XK1 = findLinearModel(dataX, thetaX, dataY, thetaY, omega)</code></pre><h3 id="Identifying-Invariant-Vector-Bundles-and-Transforming-Data"><a class="docs-heading-anchor" href="#Identifying-Invariant-Vector-Bundles-and-Transforming-Data">Identifying Invariant Vector Bundles and Transforming Data</a><a id="Identifying-Invariant-Vector-Bundles-and-Transforming-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Identifying-Invariant-Vector-Bundles-and-Transforming-Data" title="Permalink"></a></h3><p>We calculate invariant vector bundles from the linear model and project the data into this coordinate system using <a href="#InvariantModels.QPPreProcess"><code>QPPreProcess</code></a></p><pre><code class="language-julia hljs">thetaTX, dataTX, thetaTY, dataTY, dataScale, preId, R1, S1, W1 = QPPreProcess(XK1, A, omega, thetaX, dataX, thetaY, dataY, SEL; Tstep=Tstep, maxAmp=maxAmp, data_ratio=dataRatio)</code></pre><p>Here, the inverse transformation <code>W1</code> was also created.</p><h3 id="Setting-up-the-Function-Approximators"><a class="docs-heading-anchor" href="#Setting-up-the-Function-Approximators">Setting up the Function Approximators</a><a id="Setting-up-the-Function-Approximators-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-Function-Approximators" title="Permalink"></a></h3><p>We create the data structure holding our two invariant foliations using <a href="#InvariantModels.QPCombinedFoliation"><code>QPCombinedFoliation</code></a> and set up the data cache that speeds up calculations using <a href="#InvariantModels.makeCache"><code>makeCache</code></a>. Our optimisation algorithm requires setting up so-called trust-region <code>radii</code>. For housekeeping purposes we also specify using <code>dataIdV</code> that all data points are used for identifiction.</p><pre><code class="language-julia hljs">MCF, XCF = QPCombinedFoliation(NDIM, 2, fourier_order, R_order, U_order, S_order, V_order, R1, S1, MK1, zero(XK1), sparse=false)
# creating a cache
XCFcache = makeCache(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY)
dataIdV = Array{Any,1}(undef, 1)
dataIdV[1] = 1:size(thetaTX, 2)
radii = to_zero(XCF)</code></pre><h3 id="Performing-the-Optimisation"><a class="docs-heading-anchor" href="#Performing-the-Optimisation">Performing the Optimisation</a><a id="Performing-the-Optimisation-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-the-Optimisation" title="Permalink"></a></h3><p>Using function <a href="#InvariantModels.QPOptimise"><code>QPOptimise</code></a>, the optimal parameter values of our foliation are found:</p><pre><code class="language-julia hljs">QPOptimise(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY;
        maxit=8, gradient_ratio=2^(-7), gradient_stop=2^(-29), steps=STEPS, name=revision,
        cache=XCFcache,
        omega=omega, Tstep=Tstep, dataId=dataIdV[1], radii=radii)</code></pre><h3 id="Analysis-of-the-result"><a class="docs-heading-anchor" href="#Analysis-of-the-result">Analysis of the result</a><a id="Analysis-of-the-result-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-the-result" title="Permalink"></a></h3><p>The post processing step using <a href="#InvariantModels.QPPostProcess"><code>QPPostProcess</code></a> extract a reduced order model together with an invariant manifold. The manifold immersion <span>$\boldsymbol{W}$</span> is <code>MW</code>, <code>XW</code>.</p><pre><code class="nohighlight hljs">MSn, XSn, MFW, XFWoWdoWn, MW, XW = QPPostProcess(MCF, XCF, W1, omega)</code></pre><p>The instantaneous frequencies and damping ratios are also plotted</p><pre><code class="language-julia hljs">That, Rhat_r, rho, gamma = MAPFrequencyDamping(MFW, XFWoWdoWn, MSn, XSn, dispMaxAmp / dataScale)
r_data = range(0, dispMaxAmp / dataScale, length=1000)
dataFreq = abs.(That.(r_data)) / Tstep
dataDamp = -log.(abs.(Rhat_r.(r_data))) ./ abs.(That.(r_data))
dataAmp = r_data .* dataScale
# plotting
lines!(axFreq, dataFreq, dataAmp, label=&quot;DATA O($(R_order), $(S_order))&quot;, linestyle=:solid, linewidth=2)
lines!(axDamp, dataDamp, dataAmp, label=&quot;DATA O($(R_order), $(S_order))&quot;, linestyle=:solid, linewidth=2)</code></pre><p><img src="fig-data-shawpierre-2p-8.0-SIMAMP1.0-AMP0.25-F3-R7-U7-V7-S7-MODE1-FOIL.svg" alt/></p><h3 id="Error-Analysis"><a class="docs-heading-anchor" href="#Error-Analysis">Error Analysis</a><a id="Error-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Analysis" title="Permalink"></a></h3><p>To make sense of the results, we analyse the fitting error, which is the residual of the invariance equation divided by the distance from the invariant torus</p><p class="math-container">\[    E = \frac{\left| \boldsymbol{R}\left(\boldsymbol{U}\left(\boldsymbol{x}_k,\theta_k\right),\theta_k\right) - \boldsymbol{U}\left(\boldsymbol{y}_k,\theta_k +\omega\right) \right|}{\left| \boldsymbol{x}_k - K(\theta_k) \right|}\]</p><p>The amplitude of a given point is calculated by</p><p class="math-container">\[    A = \left| \boldsymbol{W}(\boldsymbol{U}(\boldsymbol{x}_k, \theta_k)) \right|\]</p><p>The following call calculates <span>$A$</span> as <code>OnManifoldAmplitude</code> and various statistics about <code>E</code> as a function of the amplitude.</p><pre><code class="language-julia hljs">OnManifoldAmplitude, hsU, errMaxX, errMaxY, errMinX, errMinY, errMeanX, errMeanY, errStdX = ErrorStatistics(MCF, XCF, MW, XW, thetaTX, dataTX, thetaTY, dataTY; dataScale=dataScale, cache=XCFcache)
den = Makie.KernelDensity.kde(sort(vcat(OnManifoldAmplitude, -OnManifoldAmplitude)))
atol = eps(maximum(den.density))
den.density[findall(isapprox.(den.density, 0, atol=atol))] .= atol
dataDensityX = den.density
dataDensityY = den.x</code></pre><p>The error and data distribution is the plotted</p><pre><code class="language-julia hljs">axErr = Axis(fig[1, 2], xscale=log10)
axDense = Axis(fig[1, 1], xscale=log10)
xlims!(axErr, 1e-6, 1e-1)
ylims!(axErr, 0, maxAmp)
xlims!(axDense, 1e-2, 100)
ylims!(axDense, 0, maxAmp)

lines!(axDense, dataDensityX, dataDensityY)
heatmap!(axErr, hsU, colormap=GLMakie.Reverse(:greys))
lines!(axErr, errMaxX, errMaxY, linestyle=:solid, linewidth=2, color=:red)
lines!(axErr, errMinX, errMinY, linestyle=:solid, linewidth=2, color=:red)
lines!(axErr, errMeanX, errMeanY, linestyle=:dash, linewidth=2, color=:blue)
lines!(axErr, errMeanX .+ errStdX, errMeanY, linestyle=:dot, linewidth=2, color=:green)</code></pre><p>Finally plot legends are displayed</p><pre><code class="language-julia hljs"># creating the legend
fig[1, 5] = Legend(fig, axFreq, merge=true, unique=true, labelsize=16, backgroundcolor=(:white, 0), framevisible=false, rowgap=1)
resize_to_layout!(fig)
display(fig)</code></pre><p><img src="fig-data-shawpierre-2p-8.0-SIMAMP1.0-AMP0.25-F3-R7-U7-V7-S7-MODE1.svg" alt/></p><h2 id="Functional-Representation"><a class="docs-heading-anchor" href="#Functional-Representation">Functional Representation</a><a id="Functional-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-Representation" title="Permalink"></a></h2><p>All data structures follow the conventions of <a href="https://juliamanifolds.github.io/ManifoldsBase.jl">ManifoldsBase.jl</a>. For example, the representation of the submersion <span>$\boldsymbol{U}$</span> is given as two components <code>MU</code> and <code>XU</code>, where <code>MU</code> describes the function and <code>XU</code> contains the parameters of <span>$\boldsymbol{U}$</span>.</p><h3 id="Interpolation-in-Fourier-Space"><a class="docs-heading-anchor" href="#Interpolation-in-Fourier-Space">Interpolation in Fourier Space</a><a id="Interpolation-in-Fourier-Space-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-in-Fourier-Space" title="Permalink"></a></h3><p>When representing periodic functions, we use Fourier collocation. The grid of the collocation is given by</p><p class="math-container">\[\vartheta_{1}=0,\ldots,\vartheta_{2\ell+1}=\frac{2\ell}{2\ell+1}2\pi,\]</p><p>where <span>$\ell$</span> is the highest resolved Fourier harmonic. The grid has <span>$2\ell+1$</span> nodes, which is the same as the number of Fourier coefficients that can uniquely represent a periodic function on the grid.</p><p>Given a set of points on the grid <span>$\boldsymbol{x}_{j}=\boldsymbol{x}\left(\vartheta_{j}\right)$</span>, we can use an interpolation to reconstruct the periodic function on the interval <span>$[0,2\pi)$</span> using</p><p class="math-container">\[\boldsymbol{x}\left(\theta\right)=\sum_{j=1}^{2\ell+1}\gamma\left(\theta-\vartheta_{j}\right)\boldsymbol{x}_{j},\]</p><p>where </p><p class="math-container">\[\gamma\left(\theta\right)=\frac{1}{2\ell+1}\frac{\sin\frac{2\ell+1}{2}\theta}{\sin\frac{1}{2}\theta}.\]</p><p>Let us define the matrix <span>$\boldsymbol{X} = (\boldsymbol{x}_{j}, \ldots, \boldsymbol{x}_{2\ell+1})$</span>  and the interpolation vector for a given value of <span>$\theta$</span> by</p><p class="math-container">\[\boldsymbol{t}_\theta = (\gamma\left(\theta-\vartheta_{1}\right), \ldots, \gamma\left(\theta-\vartheta_{2\ell+1}\right))^T,\]</p><p>then the function evaluation <span>$\boldsymbol{x}\left(\theta\right)$</span> is a matrix-vector product</p><p class="math-container">\[\boldsymbol{x}\left(\theta\right)= \boldsymbol{X} \boldsymbol{t}_\theta.\]</p><h3 id="Input-to-Data-driven-Methods"><a class="docs-heading-anchor" href="#Input-to-Data-driven-Methods">Input to Data-driven Methods</a><a id="Input-to-Data-driven-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Input-to-Data-driven-Methods" title="Permalink"></a></h3><p>We assume that the data is produced by an unknown map <span>$\boldsymbol{F}$</span>, such that </p><p class="math-container">\[\boldsymbol{y}_{k} = \boldsymbol{F}\left(\boldsymbol{x}_{k},\theta_{k}\right).\]</p><p>When considering trajectories for some set of consecutive indices we have <span>$\boldsymbol{x}_{k+1}=\boldsymbol{y}_{k}$</span>.  The data we analyse is organised into matrices</p><p class="math-container">\[\begin{aligned}
\boldsymbol{X} &amp;= (\boldsymbol{x}_1,\ldots, \boldsymbol{x}_N) \\
\boldsymbol{Y} &amp;= (\boldsymbol{y}_1,\ldots, \boldsymbol{x}_N) \\
\boldsymbol{\Theta}_x &amp;= (\boldsymbol{t}_{\theta_1},\ldots, \boldsymbol{t}_{\theta_N}) \\
\boldsymbol{\Theta}_y &amp;= (\boldsymbol{t}_{\theta_1+\omega},\ldots, \boldsymbol{t}_{\theta_N + \omega})
\end{aligned}\]</p><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><h3 id="Finding-a-Linear-Model-from-Data"><a class="docs-heading-anchor" href="#Finding-a-Linear-Model-from-Data">Finding a Linear Model from Data</a><a id="Finding-a-Linear-Model-from-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-Linear-Model-from-Data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.findLinearModel" href="#InvariantModels.findLinearModel"><code>InvariantModels.findLinearModel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findLinearModel(dataX, thetaX, dataY, thetaY, omega; ratio=0.5, steps=3)</code></pre><p>The input arguments arguments</p><ul><li><code>dataX</code> is matrix <span>$\boldsymbol{X}$</span>. Each column corresponts to a data point.</li><li><code>dataY</code> is matrix <span>$\boldsymbol{Y}$</span>.</li><li><code>thetaX</code> is matrix <span>$\boldsymbol{\Theta}_x$</span></li><li><code>thetaY</code> is matrix <span>$\boldsymbol{\Theta}_y$</span></li><li><code>ratio</code> the ratio of data to be kept at the final step</li><li><code>steps</code> the number of steps to take to find </li></ul><p>Finds a linear model in the form of</p><p class="math-container">\[\begin{aligned}
\boldsymbol{x}_{k+1} &amp;= \boldsymbol{A}(\theta_k) \boldsymbol{x}_k + \boldsymbol{b}(\theta_k) \\
\theta_{k+1} &amp;= \theta_k + \omega
\end{aligned}\]</p><p>and calculates the invariant torus represented by <span>$\boldsymbol{K}$</span> from the equation</p><p class="math-container">\[\boldsymbol{K}(\theta+\omega) = \boldsymbol{A}(\theta) \boldsymbol{K}(\theta) + \boldsymbol{b}(\theta)\]</p><p>The output is </p><pre><code class="nohighlight hljs">A, b, MK, XK</code></pre><ul><li><code>A</code> is a 3-index array representing <span>$\boldsymbol{A}(\theta)$</span></li><li><code>b</code> is a 2-index array representing <span>$\boldsymbol{b}(\theta)$</span></li><li><code>MK</code>, <code>XK</code> represent to torus parametrisation <span>$K$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qplinearid.jl#L75-L105">source</a></section></article><h3 id="Data-Structures-and-Related-Functions"><a class="docs-heading-anchor" href="#Data-Structures-and-Related-Functions">Data Structures and Related Functions</a><a id="Data-Structures-and-Related-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures-and-Related-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.getgrid" href="#InvariantModels.getgrid"><code>InvariantModels.getgrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getgrid(n::Integer)</code></pre><p>Returns a uniform grid on the interval <span>$[0, 2 \pi)$</span> with <span>$2n + 1$</span> number of points. The end point <span>$2\pi$</span> is not part of the grid.</p><p>The number <span>$n$</span> corresponds to the number of Fourier harmonics that can be represented on the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPConstant" href="#InvariantModels.QPConstant"><code>InvariantModels.QPConstant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">M = QPConstant(dim_out, fourier_order, field::AbstractNumbers=ℝ)</code></pre><p>Creates a vector valued periodic function with <code>fourier_order</code> Fourier harmonics. The parameters are</p><ul><li><code>dim_out</code> number of dimensions,</li><li><code>fourier_order</code> number of Fourier harmonics,</li><li><code>field</code> whether it is real valued <code>field=ℝ</code> or complex valued <code>field=ℂ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L1221-L1228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPPolynomial" href="#InvariantModels.QPPolynomial"><code>InvariantModels.QPPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">M = QPPolynomial(dim_out, dim_in, fourier_order, min_polyorder, max_polyorder, field::AbstractNumbers=ℝ; perp_idx=1:dim_in)</code></pre><p>Creates a vector valued polynomial that also a periodic function of another variable.</p><p class="math-container">\[    \boldsymbol{y} = P(\boldsymbol{x}, \theta)\]</p><p>The parameters are</p><ul><li><code>dim_out</code> number of output dimensions, i.e., the dimensionality of <span>$\boldsymbol{y}$</span></li><li><code>dim_in</code> number independent variables, i.e., the dimensionality of <span>$\boldsymbol{x}$</span></li><li><code>fourier_order</code> number of Fourier harmonics for the independent variable <span>$\theta$</span></li><li><code>min_polyorder</code> the lowest monomial order contained in polynomial <span>$P$</span></li><li><code>max_polyorder</code> the highest monomial order contained in polynomial <span>$P$</span></li><li><code>field</code> whether it is real valued <code>field=ℝ</code> or complex valued <code>field=ℂ</code></li><li><code>perp_idx</code> the indices of idependent variables in <span>$\boldsymbol{x}$</span> that must appear at least linearly in each monomial.  For example if we have 4 variables and <code>perp_idx = [1 2]</code>, the monomial <span>$x_3 x_4$</span> is not part of the polynomial, because they do not contains any of <span>$x_1$</span> or <span>$x_2$</span>. However, <span>$x_1 x_3$</span> is part of the polynomial, because <span>$1$</span> is among the indices given by <code>perp_idx</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L193-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.fromFunction!" href="#InvariantModels.fromFunction!"><code>InvariantModels.fromFunction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fromFunction!(M::QPPolynomial, W, fun)</code></pre><p>Taylor expands Julia function <code>fun</code> to a polynomial <a href="#InvariantModels.QPPolynomial"><code>QPPolynomial</code></a>, whose structure is prescribed by <code>M</code>. Function <span>$f$</span> = <code>fun</code> must have two arguments</p><p class="math-container">\[    f : \mathbb{R}^n \times [0,2\pi) \to \mathbb{R}^m,\]</p><p>where <span>$n$</span> is <code>dim_in</code> and <span>$m$</span> is the <code>dim_out</code> parameter of polynomial <code>M</code>. The result is copied into <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L234-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.fromFunction" href="#InvariantModels.fromFunction"><code>InvariantModels.fromFunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">W = fromFunction(M::QPPolynomial, fun)</code></pre><p>Same as <a href="#InvariantModels.fromFunction!"><code>fromFunction!</code></a>, except that the result is returned in <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.Eval" href="#InvariantModels.Eval"><code>InvariantModels.Eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">res = Eval(M::QPPolynomial, X, theta::Matrix, data::Matrix; cache=makeCache(M, X, theta, data))</code></pre><p>Same as <a href="#InvariantModels.Eval!"><code>Eval!</code></a>, except that the result is returned in <code>res</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.Eval!" href="#InvariantModels.Eval!"><code>InvariantModels.Eval!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Eval!(res, M::QPPolynomial, X, theta::Matrix, data::Matrix; cache=makeCache(M, X, theta, data))</code></pre><p>Evaluate the polynomial <code>M</code>, <code>X</code> at multiple data points. The data points are given by <code>theta</code> and <code>data</code>. Each column of <code>theta</code> and <code>data</code> corresponds to a single data point. The result is copied into <code>res</code>.</p><p>The matrix <code>theta</code> contains the interpolation weights of Fourier collocation and not the actual values of <span>$\theta$</span>. Generally, these interpolation weights are pre-calculated, which avoids repeated calculation. The number of rows of <span>$\theta$</span> is the same as <span>$2 n + 1$</span>, where <span>$n$</span> is the number of Fourier modes resolved by polynomial <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.mapFromODE" href="#InvariantModels.mapFromODE"><code>InvariantModels.mapFromODE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapFromODE(M::QPPolynomial, W, fun, par, omega, dt, step)</code></pre><p>Creates a Poincare map from the vector field given by <code>fun</code> and places it into the polynomial <code>M</code>, <code>X</code>. The parameters are</p><ul><li><code>M</code> ,<code>W</code> the polynomial to contain the result.</li><li><code>fun</code> the vector field in the form of <code>fun(dx, x, p, theta)</code>, where <code>x</code> is the input state var, <code>dx</code> is the time-derivative <span>$\frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}t}$</span>, <code>p</code> is the parameter, which equals to <code>par</code> and <code>theta</code> is the phase of forcing on the interval <span>$[0, 2\pi)$</span>.</li><li><code>par</code> is the parameter (vector) of <code>fun</code>.</li><li><code>omega</code> is the forcing frequency. The independent variable <code>t</code> of <code>fun</code> is calculated as <code>theta</code> = <span>$\omega t$</span>, where <span>$t$</span> is the independent variable (time).</li><li><code>dt</code> is the time step of the integrator.</li><li><code>step</code> is time period that the differential equation is solved for.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L280-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.toFourier" href="#InvariantModels.toFourier"><code>InvariantModels.toFourier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MF, XF = toFourier(M::QPPolynomial, X)</code></pre><p>Converts the polynomial <code>M</code>, <code>X</code> to another polynomial that contains Fourier coefficients as opposed to collocated values of the polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qppolynomial.jl#L929-L933">source</a></section></article><h3 id="Semi-analytic-Reduction-to-Invariant-Manifolds"><a class="docs-heading-anchor" href="#Semi-analytic-Reduction-to-Invariant-Manifolds">Semi-analytic Reduction to Invariant Manifolds</a><a id="Semi-analytic-Reduction-to-Invariant-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Semi-analytic-Reduction-to-Invariant-Manifolds" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPMAPTorusManifold" href="#InvariantModels.QPMAPTorusManifold"><code>InvariantModels.QPMAPTorusManifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPMAPTorusManifold(MP::QPPolynomial, XP, omega, SEL; 
                        threshold = 0.1, 
                        resonance = false, 
                        rom_order = max_polyorder)</code></pre><p>The inputs are the following</p><ul><li><code>MP</code>, <code>XP</code> the Poincare map that describes the dynamics.</li><li><code>omega</code> the phase shift at each time-step</li><li><code>SEL</code> which spectral bundles to use for the calculation of the invariant manifold</li><li><code>threshold</code> if a near resonance is greater than this value, it is ignored</li><li><code>resonance</code>: when <code>false</code> the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.</li><li><code>rom_order</code> what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map <code>MP</code>, <code>XP</code>.</li></ul><p>This function does three calculations</p><ol><li>Calculates the invariant torus using Newton&#39;s method. The startnig iteration is at the origin.</li><li>Calculates the linear system about the invariant torues and decomposes it into invariant vector bundles. The bundles are ordered by the corresponding spectrum. The bundles with the greatest spectral radius appear first.</li><li>Given the invariant bundles about the torus, calculate the invariant manifold tangent to the selected vector bundles. The selection is done by <code>SEL</code>.</li></ol><p>Return values are:</p><pre><code class="nohighlight hljs">MK, XK, MSn, XSn, MWn, XWn, MSd, XSd, XWre</code></pre><ul><li><code>MK</code>, <code>XK</code> represent the invariant torus</li><li><code>MSn</code>, <code>XSn</code> the normal form of the conjugate dynamics on the invariant manifold</li><li><code>MWn</code>, <code>XWn</code> the manifold immersion in the coordinate system of the invariant vector bundle, selected by <code>SEL</code></li><li><code>MSd</code>, <code>XSd</code> the full system <code>MP</code>, <code>XP</code> transformed to the coordinate system of the vector bundle decomposition</li><li><code>XWre</code> the transformation from the vector bundles to the original coordinate system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpdirectmanifold.jl#L246-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPODETorusManifold" href="#InvariantModels.QPODETorusManifold"><code>InvariantModels.QPODETorusManifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPODETorusManifold(MP::QPPolynomial, XP, omega, SEL; 
                        threshold = 0.1, 
                        resonance = false, 
                        rom_order = max_polyorder)</code></pre><p>This is the equivalent version of <a href="#InvariantModels.QPMAPTorusManifold"><code>QPMAPTorusManifold</code></a> for vector fields.</p><p>The inputs are the following</p><ul><li><code>MP</code>, <code>XP</code> the vector field that describes the dynamics.</li><li><code>omega</code> is the forcing frequency</li><li><code>SEL</code> which spectral bundles to use for the calculation of the invariant manifold</li><li><code>threshold</code> if a near resonance is greater than this value, it is ignored</li><li><code>resonance</code>: when <code>false</code> the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.</li><li><code>rom_order</code> what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map <code>MP</code>, <code>XP</code>.</li></ul><p>This function does three calculations</p><ol><li>Calculates the invariant torus using Newton&#39;s method. The startnig iteration is at the origin.</li><li>Calculates the linear system about the invariant torues and decomposes it into invariant vector bundles. The bundles are ordered by the corresponding spectrum. The bundles with the greatest spectral radius appear first.</li><li>Given the invariant bundles about the torus, calculate the invariant manifold tangent to the selected vector bundles. The selection is done by <code>SEL</code>.</li></ol><p>Return values are:</p><pre><code class="nohighlight hljs">MK, XK, MSn, XSn, MWn, XWn, MSd, XSd, XWre, Lambda</code></pre><ul><li><code>MK</code>, <code>XK</code> represent the invariant torus</li><li><code>MSn</code>, <code>XSn</code> the normal form of the conjugate dynamics on the invariant manifold</li><li><code>MWn</code>, <code>XWn</code> the manifold immersion in the coordinate system of the invariant vector bundle, selected by <code>SEL</code></li><li><code>MSd</code>, <code>XSd</code> the full system <code>MP</code>, <code>XP</code> transformed to the coordinate system of the vector bundle decomposition</li><li><code>XWre</code> the transformation from the vector bundles to the original coordinate system</li><li><code>Lambda</code> is the linear part of the system about the invariant torus in the coordinate system of the vector bundles. This is for debug purposes only, it should be a diagonal matrix for each collocation point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpdirectmanifold.jl#L299-L331">source</a></section></article><h3 id="Manifolds-via-Invariant-Foliations"><a class="docs-heading-anchor" href="#Manifolds-via-Invariant-Foliations">Manifolds via Invariant Foliations</a><a id="Manifolds-via-Invariant-Foliations-1"></a><a class="docs-heading-anchor-permalink" href="#Manifolds-via-Invariant-Foliations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPGraphStyleFoliations" href="#InvariantModels.QPGraphStyleFoliations"><code>InvariantModels.QPGraphStyleFoliations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPGraphStyleFoliations(MP::QPPolynomial, XP, omega, SEL; dataScale=1, resonance=false, threshold=0.1, rom_order=max_polyorder)</code></pre><p>The purpose of this function is to calculate two complementary invariant foliations about an invariant torus and then extract the invariant manifold that is the zero level set of the second foliation. The invariant manifold has the same dynamics as the first foliation.</p><p>The inputs are the following</p><ul><li><code>MP</code>, <code>XP</code> the Poincare map that describes the dynamics.</li><li><code>omega</code> the phase shift at each time-step</li><li><code>SEL</code> which spectral bundles to use for the calculation of the invariant manifold</li><li><code>dataScale</code> is the scaling factor that scales the coordinate system of the invariant manifold. This scaling is used when we would like to compare the invariant manifold identified from data that has been scaled. Using the same scaling factor makes this comparison possible.</li><li><code>threshold</code> if a near resonance is greater than this value, it is ignored</li><li><code>resonance</code>: when <code>false</code> the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.</li><li><code>rom_order</code> what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map <code>MP</code>, <code>XP</code>.</li></ul><p>Return values are:</p><pre><code class="nohighlight hljs">MRf, XRf, MW, XW, MRt, XRt, MUV, XUVflat, MSt, XSt, MVU, XVUflat</code></pre><ul><li><code>MRf</code>, <code>XRf</code> the conjugate dynamics of the first invariant foliation (<code>SEL</code>) in normal form coordinates and with Fourier coefficients</li><li><code>MW</code>, <code>XW</code> the immersion of the invariant manifold in the original coordinate system</li></ul><p>The outputs that could be used to set initial conditions to a foliation</p><ul><li><code>MRt</code>, <code>XRt</code> the conjugate dynamics of the first invariant foliation (<code>SEL</code>) when the foliation is parametrised graph-style</li><li><code>MUV</code>, <code>XUVflat</code></li><li><code>MSt</code>, <code>XSt</code> the conjugate dynamics of the second invariant foliation when the foliation is parametrised graph-style</li><li><code>MVU</code>, <code>XVUflat</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpdirectfoliation.jl#L299-L326">source</a></section></article><h3 id="Frequencies-and-Damping-Ratios"><a class="docs-heading-anchor" href="#Frequencies-and-Damping-Ratios">Frequencies and Damping Ratios</a><a id="Frequencies-and-Damping-Ratios-1"></a><a class="docs-heading-anchor-permalink" href="#Frequencies-and-Damping-Ratios" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.MAPFrequencyDamping" href="#InvariantModels.MAPFrequencyDamping"><code>InvariantModels.MAPFrequencyDamping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">MAPFrequencyDamping(MW::QPFourierPolynomial, XW, MR::QPFourierPolynomial, XR, amp_max; output = Diagonal(I,dim_out))</code></pre><p>Calculates corrected frequencies and damping ratios for a centre type equilibrium. The inputs are</p><ul><li><code>MW</code>, <code>XW</code> is the manifold immersion <span>$\boldsymbol{W}: \mathbb{R}^2 \times [0,2\pi) \to \mathbb{R}^n$</span></li><li><code>MR</code>, <code>XR</code> is the conjugate dynamics <span>$\boldsymbol{W}: \mathbb{R}^2 \times [0,2\pi) \to \mathbb{R}^2$</span></li><li><code>amp_max</code> is the maximum amplitude to be considered</li><li><code>output</code> is a matrix <span>$\boldsymbol{M}$</span> that is used to calculate the instantaneous amplitude by pre multiplying the immersion: <span>$\boldsymbol{M} \boldsymbol{W}$</span>.</li></ul><p>The inputs are such that they satisfy the invariance equation</p><p class="math-container">\[\boldsymbol{W}\left(\boldsymbol{R}\left(\boldsymbol{z},\theta\right),\theta+\omega\right)=\boldsymbol{F}\left(\boldsymbol{W}\left(\boldsymbol{z},\theta\right),\theta\right),\]</p><p>where <span>$\boldsymbol{F}$</span> is the map of the original dynamics. Given that the invariant manifold is in a normal form, we have the following structure to the conjugate map</p><p class="math-container">\[\boldsymbol{R}\left(\boldsymbol{z}\right)=\begin{pmatrix}s\left(z,\overline{z}\right)\\
\overline{s}\left(z,\overline{z}\right)
\end{pmatrix}\]</p><p>Using a the transformation <span>$z=\rho\left(r\right)\exp\left(i\beta+i\alpha\circ\rho\left(r\right)\right)$</span> we can write the manifold immersion as</p><p class="math-container">\[\widehat{\boldsymbol{W}}\left(r,\beta,\theta\right)=\boldsymbol{W}\left(\rho\left(r\right)\exp\left(i\beta+i\alpha\circ\rho\left(r\right)\right),\rho\left(r\right)\exp\left(-i\beta-i\alpha\circ\rho\left(r\right)\right),\theta\right)\]</p><p>so that the invariance equation holds</p><p class="math-container">\[\widehat{\boldsymbol{W}}\left(R\left(r\right),\beta+T\left(r\right),\theta+\omega\right)=\boldsymbol{F}\left(\widehat{\boldsymbol{W}}\left(r,\beta,\theta\right),\theta\right),\]</p><p>where <span>$R$</span> and <span>$T$</span> are calculated using the same transformation.</p><p>The unknown functions <span>$\rho$</span> and <span>$\alpha$</span> are calculated such that </p><ol><li>the amplitude of a tori as a function of <span>$r$</span> is the same as <span>$r$</span> and </li><li>there is zero phase shift between any two tori with different amplitudes with respect to parameter <span>$\beta$</span>.</li></ol><p>Return values are</p><pre><code class="nohighlight hljs">T, R_r, rho, alpha</code></pre><ul><li><code>T</code> is the function <span>$T : [0,\infty) \to \mathbb{R}$</span></li><li><code>R_r</code> is the function <span>$r \mapsto R(r) / r$</span></li><li><code>rho</code> is the same as <span>$\rho$</span></li><li><code>alpha</code> is the same as <span>$\alpha$</span></li></ul><p>The instantaneous frequency is calculated as</p><p class="math-container">\[\omega(r) = \frac{T(r)}{\Delta t},\]</p><p>the instantaneous damping is calculated as</p><p class="math-container">\[\zeta(r) = -\frac{\log r^{-1} R(r)}{T(r)},\]</p><p>where <span>$\Delta t$</span> is the sampling period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpfrequencydamping.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.ODEFrequencyDamping" href="#InvariantModels.ODEFrequencyDamping"><code>InvariantModels.ODEFrequencyDamping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ODEFrequencyDamping(MW::QPFourierPolynomial, XW, MR::QPFourierPolynomial, XR, amp_max; output = Diagonal(I,dim_out))</code></pre><p>The inputs and outputs are the same as <a href="#InvariantModels.MAPFrequencyDamping"><code>MAPFrequencyDamping</code></a>, except that the interpretation of the input/output is slightly different. The input satisfies the invariance equation</p><p class="math-container">\[D_1\boldsymbol{W}\left(\boldsymbol{z},\theta\right) \boldsymbol{R}\left(\boldsymbol{z},\theta\right) + D_1\boldsymbol{W}\left(\boldsymbol{z},\theta\right) \omega = \boldsymbol{F}\left(\boldsymbol{W}\left(\boldsymbol{z},\theta\right),\theta\right),\]</p><p>where <span>$\boldsymbol{F}$</span> is a vector field.</p><p>From the output, the instantaneous frequency is </p><p class="math-container">\[\omega(r) = T(r),\]</p><p>the instantaneous damping is calculated as</p><p class="math-container">\[\zeta(r) = -\frac{r^{-1} R(r)}{T(r)}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpfrequencydamping.jl#L63-L80">source</a></section></article><h3 id="Generating-Data"><a class="docs-heading-anchor" href="#Generating-Data">Generating Data</a><a id="Generating-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.generate" href="#InvariantModels.generate"><code>InvariantModels.generate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate(NDIM, rhs!, maxIC, nruns, npoints, fourier_order, omega, Tstep, A, XWre)</code></pre><p>Creates a data set from a differential equation, represented by <code>rhs!</code>. An invariant torus is found by observing a convergent simulation to the torus. The initial conditions are sampled from an ellipsoid about the torus. The directions of the ellipsoid are given by the linear transformation <code>XWre</code>. For each column of <code>XWre</code> the maximum amplitude is specified by the corresponding element of the vector <code>maxIC</code>.</p><p>The input parameters are</p><ul><li><code>NDIM</code> the dimensionality of the system</li><li><code>rhs!</code> the vector field in the form of <code>fun(dx, x, p, theta)</code>, where <code>x</code> is the input state var, <code>dx</code> is the time-derivative <span>$\frac{\mathrm{d}\boldsymbol{x}}{\mathrm{d}t}$</span>, <code>p</code> is the parameter, which equals to <code>par</code> and <code>theta</code> is the phase of forcing on the interval <span>$[0, 2\pi)$</span>.</li><li><code>maxIC</code> is a vector of size <code>NDIM</code>, containing the maximum simulation amplitudes in each direction of <code>XWre</code></li><li><code>nruns</code> the number of simulation runs</li><li><code>npoints</code> the length of the trajectory for each simulation run</li><li><code>fourier_order</code> the number of Fourier harmonics to consider when calculating <span>$\boldsymbol{\Theta}_x$</span>, <span>$\boldsymbol{\Theta}_y$</span></li><li><code>omega</code> the forcing frequency, as in <span>$\dot{\theta} = \omega$</span></li><li><code>Tstep</code> the time step between two samples of the trajectory, denoted by <span>$\Delta t$</span></li><li><code>A</code> the parameter <code>p</code> of the vector field</li><li><code>XWre</code> is the transformation that defines the axes of the ellipsoid about the invariant torus</li></ul><p>The function returns</p><pre><code class="nohighlight hljs">dataX, dataY, thetaX, thetaY, thetaNIX, thetaNIY</code></pre><ul><li><code>dataX</code> is matrix <span>$\boldsymbol{X}$</span>. Each column corresponts to a data point.</li><li><code>dataY</code> is matrix <span>$\boldsymbol{Y}$</span>.</li><li><code>thetaX</code> is matrix <span>$\boldsymbol{\Theta}_x$</span></li><li><code>thetaY</code> is matrix <span>$\boldsymbol{\Theta}_y$</span></li><li><code>thetaNIX</code> is the vector <span>$(\theta_1, \ldots, \theta_N)$</span></li><li><code>thetaNIY</code> is the vector <span>$(\theta_1 + \omega \Delta t, \ldots, \theta_N + \omega \Delta t)$</span></li></ul><p>space</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpgenerate.jl#L10-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.generateMap" href="#InvariantModels.generateMap"><code>InvariantModels.generateMap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generateMap(MF, XF, MK, XK, maxIC, nruns, npoints, fourier_order, omega, Tstep)</code></pre><p>Similar to <a href="#InvariantModels.generate"><code>generate</code></a>, except that it simulates a discrete-time system.</p><p>The inputs differ from <a href="#InvariantModels.generate"><code>generate</code></a>. Instead of the vector field, the following must be specified</p><ul><li><code>MF</code>, <code>XF</code> the discrete-time map of the system</li><li><code>MK</code>, <code>XK</code> the invariant torus arbout which the system is simulated.</li></ul><p>There is no way the specify an ellipsoid for initial conditions, they are taken from a sphere of radius <code>maxIC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpgenerate.jl#L114-L123">source</a></section></article><h3 id="Identfying-Invariant-Foliations-from-Data"><a class="docs-heading-anchor" href="#Identfying-Invariant-Foliations-from-Data">Identfying Invariant Foliations from Data</a><a id="Identfying-Invariant-Foliations-from-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Identfying-Invariant-Foliations-from-Data" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPPreProcess" href="#InvariantModels.QPPreProcess"><code>InvariantModels.QPPreProcess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPPreProcess(K, A, omega, thetaX, dataX, thetaY, dataY, sel; Tstep=1.0, maxAmp=Inf, data_ratio=1.0, preId=[])</code></pre><p>This function is called after a linear model has been identified using <a href="#InvariantModels.findLinearModel"><code>findLinearModel</code></a>. The following calculations are carried out</p><ol><li>decompose the linear dynamics into invariant vector bundles.</li><li>project the data onto two invariant vector bundles, one that corresponds to the spectral circles selected by <code>sel</code> and the the remaining bundle. In this coordinate system the approximate linear model represented by <code>A</code> becomes block-diagonal.</li><li></li></ol><p>The input arguments arguments</p><ul><li><code>K</code> approximate invariant torus</li><li><code>A</code> approximate linear map about the torus</li><li><code>dataX</code> is matrix <span>$\boldsymbol{X}$</span>. Each column corresponts to a data point.</li><li><code>dataY</code> is matrix <span>$\boldsymbol{Y}$</span>.</li><li><code>thetaX</code> is matrix <span>$\boldsymbol{\Theta}_x$</span> These are the interpolations vectors for Fourier collocation corresponding to <span>$\theta_k$</span>.</li><li><code>thetaY</code> is matrix <span>$\boldsymbol{\Theta}_y$</span></li><li><code>sel</code> indicates the selected vector bundles.</li><li><code>Tstep</code> is the sampling period <span>$\Delta t$</span></li><li><code>maxAmp</code> is the maximum amplitude of the data along the selected vector bundle</li><li><code>data_ratio</code> <span>$\in [0,1]$</span> the proportion of the data to be kept and the rest is removed so that it is uniformly distributed along in the neighbourhood of the selected vector bundles.</li><li><code>preId</code> if non-empty, this replaces the data filtering process.</li></ul><p>The output is</p><pre><code class="nohighlight hljs">thetaTX, dataTX, thetaTY, dataTY, dataScale, id, R1, S1, W1</code></pre><ul><li><code>thetaTX, dataTX, thetaTY, dataTY</code> are the filtered and scaled data. The approximate invariant torus is subtracted and the data is transformed into the coordiante system of the approximate vector bundles calculated from <code>A</code>.</li><li><code>dataScale</code> is the scaling factor that relates the input and output <code>dataX[:,id] = dataScale * dataTX</code>.</li><li><code>id</code> the indices of the input that are brought to the output</li><li><code>R1</code> is the invariant part of the the linear system <code>A</code> that is invariant under the selected <code>sel</code> vector bundles</li><li><code>S1</code> is the invariant part of the the linear system <code>A</code> that is invariant under the not selected (<code>setdiff(1:data_dim, sel)</code>) vector bundles</li><li><code>W1</code> the inverse transformation that brings that data back into the physical coordinate system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L501-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPCombinedFoliation" href="#InvariantModels.QPCombinedFoliation"><code>InvariantModels.QPCombinedFoliation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QPCombinedFoliation(dim_data, dim_latent, fourier_order, R_order, U_order, S_order, V_order, R1, S1, MK, XK; sparse=false)</code></pre><p>Creates the data structures to store a pair of foliations that might be interconnected through scaling. The invariance equations represented by a Combined Foliation are</p><p class="math-container">\[\begin{aligned}
\boldsymbol{R}\left(\boldsymbol{U}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) &amp;= \boldsymbol{U}\left(\boldsymbol{F}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}+\boldsymbol{\omega}\right)\\
\boldsymbol{S}\left(\boldsymbol{V}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}\right) &amp;= \boldsymbol{V}\left(\boldsymbol{F}\left(\boldsymbol{x},\boldsymbol{\theta}\right),\boldsymbol{\theta}+\boldsymbol{\omega}\right)
\end{aligned}\]</p><p>The input parameters are</p><ul><li><code>dim_data</code> system dimension</li><li><code>dim_latent</code> the dimension of the reduced order model</li><li><code>fourier_order</code>number of Fourier harmonics used in discretisation</li><li><code>R_order</code> the polynomial order of function <span>$\boldsymbol{R}$</span></li><li><code>U_order</code> the polynomial order of function <span>$\boldsymbol{U}$</span></li><li><code>S_order</code> the polynomial order of function <span>$\boldsymbol{S}$</span></li><li><code>V_order</code> the polynomial order of function <span>$\boldsymbol{V}$</span></li><li><code>R1</code> the initial linear part of function <span>$\boldsymbol{R}$</span></li><li><code>S1</code> the initial linear part of function <span>$\boldsymbol{S}$</span></li><li><code>MK</code>, <code>XK</code> the invariant torus</li><li><code>sparse</code> use compressed polynomials (default = <code>false</code>)</li></ul><p>The output is the data structure</p><pre><code class="nohighlight hljs">MCF, XCF</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L329-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.makeCache" href="#InvariantModels.makeCache"><code>InvariantModels.makeCache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeCache(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY)</code></pre><p>Creates a cache object for a combined foliation. The cache stores intermediate results that are not re-calculated between various steps of the optimisation. This improves performance significantly.</p><p>Input:</p><ul><li><code>M</code>, <code>X</code> the combined foliation generated by <a href="#InvariantModels.QPCombinedFoliation"><code>QPCombinedFoliation</code></a></li><li><code>dataTX</code> is matrix <span>$\boldsymbol{X}$</span>. Each column corresponds to a data point.</li><li><code>dataTY</code> is matrix <span>$\boldsymbol{Y}$</span>.</li><li><code>thetaX</code> is matrix <span>$\boldsymbol{\Theta}_x$</span> These are the interpolations vectors for Fourier collocation corresponding to <span>$\theta_k$</span>.</li><li><code>thetaY</code> is matrix <span>$\boldsymbol{\Theta}_y$</span></li></ul><p>The output is a cache object <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L807-L820">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.updateCache!" href="#InvariantModels.updateCache!"><code>InvariantModels.updateCache!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">updateCache!(cache::FCache, M, X, thetaX, dataTX, thetaY, dataTY)</code></pre><p>The same argument as <a href="#InvariantModels.makeCache"><code>makeCache</code></a>, expect that it updates <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L879-L883">source</a></section><section><div><pre><code class="language-julia hljs">updateCache!(cache::FCache, M, X, thetaX, dataTX, thetaY, dataTY, sel)</code></pre><p>The same input argument as <a href="#InvariantModels.makeCache"><code>makeCache</code></a>, expect that it updates <code>cache</code> only for the component of the foliation given by <code>sel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L935-L939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPOptimise" href="#InvariantModels.QPOptimise"><code>InvariantModels.QPOptimise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPOptimise(MCF::QPCombinedFoliation, XCF, thetaTX, dataTX, thetaTY, dataTY;
    maxit=24, 
    gradient_ratio=2^(-7), gradient_stop=2^(-29), 
    steps=400, 
    name=&quot;default&quot;,
    cache=makeCache(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY),
    omega=1.0, Tstep=1.0, dataScale=1.0, dataId=1:size(thetaTX, 2), radii=to_zero(XCF), skipRS=false)</code></pre><p>Use optimisation to fit the parameters of the combined foliation to data.</p><p>Input parameters are</p><ul><li><code>MCF</code>, <code>XCF</code> the combined foliation</li><li><code>thetaTX</code>, <code>dataTX</code>, <code>thetaTY</code>, <code>dataTY</code> the data</li><li><code>maxit</code> maximum number of iterations within one trust-regions subproblem solution</li><li><code>gradient_ratio</code> the subproblem solution stops once the norm of the gradient is reduced by this factor</li><li><code>gradient_stop</code> the subproblem solution stops when the norm of the gradient is below this value</li><li><code>steps</code> the number of subproblem solutions as we iterate over the components of the combined foliation</li><li><code>name</code> the name of the problem, used for logging purposes</li><li><code>cache</code> is created by <a href="#InvariantModels.makeCache"><code>makeCache</code></a></li><li><code>omega</code> the forcing shift-angle</li><li><code>Tstep</code> the sampling period of the data <span>$\Delta t$</span></li><li><code>dataScale</code> the scaling factor used to scale the data</li><li><code>dataId</code> the indices of the data points from the original data set</li><li><code>radii</code> initial trust-regions radii for each component of the combined foliation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1745-L1770">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPPostProcess" href="#InvariantModels.QPPostProcess"><code>InvariantModels.QPPostProcess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPPostProcess(MCF::QPCombinedFoliation, XCF, omega, resonance=false, threshold=0.1)</code></pre><p>Extracts the invariant manifold from the combined foliation together with its dynamics. The result is in a normal form with mixed power series Fourier series form.</p><p>Paramaters:</p><ul><li><code>MCF</code>, <code>XCF</code> the combined foliation.</li><li><code>W1</code> the inverse trabsformation produced by <a href="#InvariantModels.QPPreProcess"><code>QPPreProcess</code></a></li><li><code>omega</code> the forcing shift-angle.</li><li><code>resonance</code> <code>true</code> if to account for non-autonomous internal resonances. When <code>false</code>, the result will be an autonomous normal form.</li><li><code>threshold</code> if the distance between the two side of the non-resonance criterion is less than <code>threshold</code>, it counts as an internal (or external) resonance</li></ul><p>Returns:</p><pre><code class="nohighlight hljs">MSn, XSn, MFW, XFWoWdoWn, MW, XW</code></pre><ul><li><code>MSn</code>, <code>XSn</code> the conjugate dynamics on the manifold in normal form</li><li><code>MFW</code>, <code>XFWoWdoWn</code> manifold immersion in the physical coordinate system and adapted to correspond to the normal form</li><li><code>MW</code>, <code>XW</code> manifold immersion in the coordinate system of the combined foliation (not physical coordinates)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1963-L1982">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.EvalU" href="#InvariantModels.EvalU"><code>InvariantModels.EvalU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EvalU(M::QPCombinedFoliation, X, thetaX, dataTX; cache)</code></pre><p>Evaluates the submersion <span>$\boldsymbol{U}$</span> at data points <code>thetaX</code>, <code>dataTX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1023-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.EvalV" href="#InvariantModels.EvalV"><code>InvariantModels.EvalV</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EvalV(M::QPCombinedFoliation, X, thetaX, dataTX; cache)</code></pre><p>Evaluates the submersion <span>$\boldsymbol{V}$</span> at data points <code>thetaX</code>, <code>dataTX</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1038-L1042">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.Loss" href="#InvariantModels.Loss"><code>InvariantModels.Loss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Loss(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)</code></pre><p>Returns the loss function of the combined foliation <code>M</code>, <code>X</code> at data points <code>thetaX</code>, <code>dataTX</code>, <code>thetaY</code>, <code>dataTY</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1148-L1152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.ResidualU" href="#InvariantModels.ResidualU"><code>InvariantModels.ResidualU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ResidualU(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)</code></pre><p>Returns the residual of the invariance equation for <span>$\boldsymbol{U}$</span> divided by the norm of <span>$\boldsymbol{V}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1066-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.ResidualLoss" href="#InvariantModels.ResidualLoss"><code>InvariantModels.ResidualLoss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ResidualLoss(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)</code></pre><p>Returns the loss function only for the component with <span>$\boldsymbol{U}$</span> of the combined foliation <code>M</code>, <code>X</code> at data points <code>thetaX</code>, <code>dataTX</code>, <code>thetaY</code>, <code>dataTY</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1137-L1141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.QPKernel" href="#InvariantModels.QPKernel"><code>InvariantModels.QPKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QPKernel(MF::QPCombinedFoliation, XF)</code></pre><p>Returns the root of the combined foliation in the form of <code>MK</code>, <code>XK</code>, which is the same as the invariant torus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1864-L1868">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.copyMost!" href="#InvariantModels.copyMost!"><code>InvariantModels.copyMost!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copyMost!(MCFD::QPCombinedFoliation, XCFD, MCFS::QPCombinedFoliation, XCFS)</code></pre><p>Make a best-effort attempt to copy the combined foliation <code>MCFS</code>, <code>XCFS</code> into <code>MCFD</code>, <code>XCFD</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.SetTorus!" href="#InvariantModels.SetTorus!"><code>InvariantModels.SetTorus!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SetTorus!(MCF::QPCombinedFoliation, MK::QPConstant, XK)</code></pre><p>Set the location of the torus <code>MK</code>, <code>XK</code> for the combined foliation <code>MCF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L420-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.bincuts" href="#InvariantModels.bincuts"><code>InvariantModels.bincuts</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bincuts(long_amp, trans_amps, max_amp, max_points, nbins; exponent=1)</code></pre><p>This function is used to filter out data points that are far from an invariant manifold. </p><ul><li><code>long_amps</code> vector of amplitudes along the invariant manifold</li><li><code>trans_amps</code> vector of distances from the invariant manifold</li><li><code>max_amp</code> discard points that have greater amplitude than <code>max_amp</code></li><li><code>max_points</code> the maximum number of points to return</li><li><code>nbins</code> the number of bins along which the distribution is made uniform</li><li><code>exponent</code> used to calculate bin sizes. The bins fall between the nodes of <code>range(0, max_amp, length=nbins + 1) .^ exponent</code>.</li></ul><p>Returns the indices of <code>long_amps</code> that create a uniform distribution with respect to the bins and only contain the smallest <code>trans_amps</code> values from those bins.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L430-L443">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InvariantModels.to_zero" href="#InvariantModels.to_zero"><code>InvariantModels.to_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_zero(x::ArrayPartition)</code></pre><p>Creates an <code>ArrayPartition</code> the same structure as <code>x</code> expect that each component is a single element array with zero value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rs1909/InvariantModels/blob/a5d1745a79099b5f30a5cc64b9bf38281fb94368/src/qpcombinedfoliation.jl#L1642-L1646">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 20 March 2024 15:16">Wednesday 20 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
