var documenterSearchIndex = {"docs":
[{"location":"#Invariant-Models","page":"Invariant Models","title":"Invariant Models","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"This package is an improved version of FMA. Current capabilities are","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Identifies invariant foliations in autonomous, periodic and quasi-periodic systems from data.\nCalculates invariant manifolds in autonomous, periodic and quasi-periodic systems from discrete-time systems and vector fields.\nCalculates invariant foliations in autonomous, periodic and quasi-periodic systems from discrete-time systems and vector fields.\nCalculates instantaneous frequencies and damping ratios on two-dimensional invariant manifolds.","category":"page"},{"location":"#Background","page":"Invariant Models","title":"Background","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The system in question is assumed to obey the discrete-time map","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"beginaligned\nboldsymbolx_k+1 =boldsymbolFleft(boldsymbolx_kboldsymboltheta_kright)boldsymboltheta_k+1 = boldsymboltheta_k+boldsymbolomega Delta t\nendaligned tagMAP","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"where it is assumed that Delta t is the sampling period, that is the duration of time between two samples boldsymbolx_k and boldsymbolx_k+1. or the vector field","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"beginaligned\ndotboldsymbolx =boldsymbolFleft(boldsymbolxboldsymbolthetaright)dotboldsymboltheta = boldsymbolomega\nendaligned  tagODE","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"It may be the case that variable boldsymboltheta is absent and therefore the system is autonomous.","category":"page"},{"location":"#Invariance","page":"Invariant Models","title":"Invariance","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"There are four ways to connect a low-order model boldsymbolR to boldsymbolF. The figure below shows the four combinations. Only invariant foliations and invariant manifolds produce meaningful reduced order models. Only invariant foliations and autoencoders can be fitted to data. The intersection is invariant foliations. ","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Therefore, ","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"when a system of equations is given, invariant manifolds are the most appropriate (foliations are still possible),\nwhen data is given, only invariant foliations are appropriate.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Autoencoders such as SSMLearn do not enforce invariance and therefore generate spurious results as shown in Data-Driven Reduced Order Models Using Invariant Foliations, Manifolds and Autoencoders.","category":"page"},{"location":"#Invariant-Foliations","page":"Invariant Models","title":"Invariant Foliations","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The invariance equation for foliations is","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymbolRleft(boldsymbolUleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolUleft(boldsymbolFleft(boldsymbolxboldsymbolthetaright)boldsymboltheta+boldsymbolomegaright) tagFOIL","category":"page"},{"location":"#Invariant-Manifolds","page":"Invariant Models","title":"Invariant Manifolds","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The invariance equation for manifolds is","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymbolSleft(boldsymbolVleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolVleft(boldsymbolFleft(boldsymbolxboldsymbolthetaright)boldsymboltheta+boldsymbolomegaright) tagMAN","category":"page"},{"location":"#Case-Study-of-a-Minimal-Forced-System","page":"Invariant Models","title":"Case Study of a Minimal Forced System","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We consider a forced version of the Shaw-Pierre example, that originally appeared in [].","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"beginaligned\n    dotx_1 = x_3 \n    dotx_2 = x_4 \n    dotx_3 = - c x_3 - k x_1 - kappa y_1^3 + k (x_2 - x_1) + c (x_4 - x_3) + p cos(theta+01) \n    dotx_4 = - c x_4 - k x_2 - k (x_2 - x_1) - c (x_4 - x_3) + p cos(theta) \n    dottheta = omega \nendaligned","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The parameters are k=1, kappa = 02, c = 2^-5. The forcing frequency is omega = 12 and the the forcing amplitude is p=025.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Without forcing the natural frequencies are approximately omega_1 = 1, omega_2 = sqrt3. The damping ratios are zeta_1 = 001561 and zeta_2 = 002705. The spectral quotient for the first mode is beth_1 = 3 and for the second mode is beth_2 = 1. When forcing is turned on these values change slightly due to nonlinearity.","category":"page"},{"location":"#Set-up","page":"Invariant Models","title":"Set-up","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"First we import the required packages","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"using InvariantModels\nusing GLMakie","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Consider the Shaw-Pierre vector field","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"NDIM = 4\n\nfunction shawpierre!(x, y, p, t)\n    k = 1.0\n    kappa = 0.2\n    c = 2^-5\n\n    x[1] = y[3]\n    x[2] = y[4]\n    x[3] = - c*y[3] - k*y[1] - kappa*y[1]^3 + k*(y[2]-y[1]) + c*(y[4]-y[3]) + p * cos(t+0.1)\n    x[4] = - c*y[4] - k*y[2] - k*(y[2]-y[1]) - c*(y[4]-y[3]) + p * cos(t)\n    return x\nend\n\nfunction shawpierre(z, p, t)\n    dz = zero(z)\n    return shawpierre!(dz, z, p, t)\nend","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Set up some system parameters","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Amplitude = 0.25        # forcing amplitude\nomega_ode = 1.2         # forcing frequency\n\n# parameters of the numerical method\nfourier_order = 3       # fourier harmonics to be resolved\nODE_order = 7           # polynomial order of the calculations\nSEL = [1 2]             # which invariant vector bundle to use\ndispMaxAmp = 1.0        # maximum amplitude to display","category":"page"},{"location":"#Invariant-Manifolds-of-Vector-Fields","page":"Invariant Models","title":"Invariant Manifolds of Vector Fields","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Create a polynomial MPode, XPode out of our vector field","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MPode = QPPolynomial(NDIM, NDIM, fourier_order, 0, ODE_order)\nXPode = fromFunction(MPode, (x, t) -> shawpierre(x, Amplitude, t))","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The invariant manifold can now be calculated using QPODETorusManifold:","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MK, XK, MSn, XSn, MWn, XWn, _, _, XWre, oeva = QPODETorusManifold(MPode, XPode, omega_ode, SEL, threshold=0.1, resonance=false)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The frequencies and damping ratios are extracted from the reduced order model using ODEFrequencyDamping","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"That_ode, Rhat_ode, rho_ode, gamma_ode = ODEFrequencyDamping(MWn, XWn, MSn, XSn, dispMaxAmp)\nodeAmp = range(0, dispMaxAmp, length=1000)\nodeFreq = abs.(That_ode.(odeAmp))\nodeDamp = -Rhat_ode.(odeAmp) ./ odeFreq","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The results are then plotted","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"fig = Figure(size=(1200, 400))\naxFreq = Axis(fig[1, 1])\naxDamp = Axis(fig[1, 2])\naxFreq.xlabel = \"Frequency\"\naxFreq.ylabel = \"Amplitude\"\naxDamp.xlabel = \"Damping ratio\"\naxDamp.ylabel = \"Amplitude\"\n\nlines!(axFreq, odeFreq, odeAmp, label=\"ODE O($(ODE_order)) A=$(Amplitude)\", linestyle=:dash, linewidth=2)\nlines!(axDamp, odeDamp, odeAmp, label=\"ODE O($(ODE_order)) A=$(Amplitude)\", linestyle=:dash, linewidth=2)\ndisplay(fig)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"#Invariant-Manifolds-of-Maps","page":"Invariant Models","title":"Invariant Manifolds of Maps","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"First we set up some additional parameters, such as the sampling period Delta t = Tstep","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Tstep = 0.8                 # sampling period\nomega = omega_ode * Tstep   # shift angle","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We now create a discrete-time map from the vector field by Taylor expanding an ODE solver about the origin using mapFromODE. We take 500 time steps on the interval thetatheta + Delta t. The resulting map MP, XPmap is dependent on the phase variable theta in 02pi)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MP = QPPolynomial(NDIM, NDIM, fourier_order, 0, ODE_order)\nXPmap = zero(MP)\nmapFromODE(MP, XPmap, shawpierre!, Amplitude, omega_ode, Tstep / 500, Tstep)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The invariant manifold of the map is calculated using QPMAPTorusManifold","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MK, XK, MSn, XSn, MWn, XWn, MSd, XSd = QPMAPTorusManifold(MP, XPmap, omega, SEL, threshold = 0.1, resonance = false)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The frequencies and damping ratios are extracted from the reduced order model using MAPFrequencyDamping","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"That, Rhat_r, rho, gamma = MAPFrequencyDamping(MWn, XWn, MSn, XSn, dispMaxAmp)\nmapAmp = range(0, dispMaxAmp, length=1000)\nmapFreq = abs.(That.(mapAmp)) ./ Tstep\nmapDamp = -log.(abs.(Rhat_r.(mapAmp))) ./ abs.(That.(mapAmp))","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The results are plotted","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"lines!(axFreq, mapFreq, mapAmp, label=\"MAP O($(ODE_order)) A=$(Amplitude)\", linestyle=:dashdot, linewidth=2)\nlines!(axDamp, mapDamp, mapAmp, label=\"MAP O($(ODE_order)) A=$(Amplitude)\", linestyle=:dashdot, linewidth=2)\ndisplay(fig)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"#Invariant-Foliations-of-Maps","page":"Invariant Models","title":"Invariant Foliations of Maps","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Using QPGraphStyleFoliations, two invariant foliations are calculated and the invariant manifold defined by the zero level-set of the second foliation is extracted.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MRf, XRf, MW, XW, MRt, XRt, MUt, XUt, MSt, XSt, MVt, XVt = QPGraphStyleFoliations(MP, XPmap, omega, SEL; dataScale=1, resonance=false, threshold=0.1)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The results are plotted","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MWf, XWf = toFourier(MW, XW)\nThat, Rhat_r, rho, gamma = MAPFrequencyDamping(MWf, XWf, MRf, XRf, dispMaxAmp)\nfoilAmp = range(0, dispMaxAmp, length=1000)\nfoilFreq = abs.(That.(foilAmp)) ./ Tstep\nfoilDamp = -log.(abs.(Rhat_r.(foilAmp))) ./ abs.(That.(foilAmp))\n\nlines!(axFreq, foilFreq, foilAmp, label=\"FOIL O($(ODE_order)) A=$(Amplitude)\", linestyle=:dashdot, linewidth=2)\nlines!(axDamp, foilDamp, foilAmp, label=\"FOIL O($(ODE_order)) A=$(Amplitude)\", linestyle=:dashdot, linewidth=2)\ndisplay(fig)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"#ROM-identification-from-data","page":"Invariant Models","title":"ROM identification from data","text":"","category":"section"},{"location":"#Set-up-2","page":"Invariant Models","title":"Set-up","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Importing a library to load/store data and specifying parameters","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"using BSON: @load, @save\n# parameters for the data-driven part\nmaxSimAmp = 1.0     # maximum initial condition measured from the torus\nmaxAmp = 1.0        # filter out data with amplitude greater than maxAmp\ndataRatio = 1.0     # the proportion of data to be retained when filtering (all of it)\nR_order = 7         # polynomial order of R\nU_order = 7         # polynomial order of U\nV_order = 7         # polynomial order of V\nS_order = 7         # polynomial order of S\nSTEPS = 800         # number of optimisation steps to use\n\n# the names of data files\nrevision = \"shawpierre-2p$(log2(scale_epsilon))-SIMAMP$(maxSimAmp)-AMP$(Amplitude)-F$(fourier_order)-R$(R_order)-U$(U_order)-V$(V_order)-S$(S_order)-MODE$(SEL[1])\"\ndatarevision = \"shawpierre-SIMAMP$(maxSimAmp)-AMP$(Amplitude)-F$(fourier_order)\"","category":"page"},{"location":"#Creating-data","page":"Invariant Models","title":"Creating data","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We create 600 trajectories 60 points long each using generate and save the data for future use.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"dataX, dataY, thetaX, thetaY, thetaNIX, thetaNIY = generate(NDIM, shawpierre!, ones(NDIM) * maxSimAmp, 600, 50, fourier_order, omega_ode, Tstep, Amplitude, XWre)\n@save \"data-$(datarevision).bson\" dataX dataY thetaX thetaY Tstep","category":"page"},{"location":"#Finding-an-Approximate-Linear-Model","page":"Invariant Models","title":"Finding an Approximate Linear Model","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"An approximate linear model is found about the invariant torus using findLinearModel.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"A, b, MK1, XK1 = findLinearModel(dataX, thetaX, dataY, thetaY, omega)","category":"page"},{"location":"#Identifying-Invariant-Vector-Bundles-and-Transforming-Data","page":"Invariant Models","title":"Identifying Invariant Vector Bundles and Transforming Data","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We calculate invariant vector bundles from the linear model and project the data into this coordinate system using QPPreProcess","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"thetaTX, dataTX, thetaTY, dataTY, dataScale, preId, R1, S1, W1 = QPPreProcess(XK1, A, omega, thetaX, dataX, thetaY, dataY, SEL; Tstep=Tstep, maxAmp=maxAmp, data_ratio=dataRatio)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Here, the inverse transformation W1 was also created.","category":"page"},{"location":"#Setting-up-the-Function-Approximators","page":"Invariant Models","title":"Setting up the Function Approximators","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We create the data structure holding our two invariant foliations using QPCombinedFoliation and set up the data cache that speeds up calculations using makeCache. Our optimisation algorithm requires setting up so-called trust-region radii. For housekeeping purposes we also specify using dataIdV that all data points are used for identifiction.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MCF, XCF = QPCombinedFoliation(NDIM, 2, fourier_order, R_order, U_order, S_order, V_order, R1, S1, MK1, zero(XK1), sparse=false)\n# creating a cache\nXCFcache = makeCache(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY)\ndataIdV = Array{Any,1}(undef, 1)\ndataIdV[1] = 1:size(thetaTX, 2)\nradii = to_zero(XCF)","category":"page"},{"location":"#Performing-the-Optimisation","page":"Invariant Models","title":"Performing the Optimisation","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Using function QPOptimise, the optimal parameter values of our foliation are found:","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPOptimise(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY;\n        maxit=8, gradient_ratio=2^(-7), gradient_stop=2^(-29), steps=STEPS, name=revision,\n        cache=XCFcache,\n        omega=omega, Tstep=Tstep, dataId=dataIdV[1], radii=radii)","category":"page"},{"location":"#Analysis-of-the-result","page":"Invariant Models","title":"Analysis of the result","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The post processing step using QPPostProcess extract a reduced order model together with an invariant manifold. The manifold immersion boldsymbolW is MW, XW.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MSn, XSn, MFW, XFWoWdoWn, MW, XW = QPPostProcess(MCF, XCF, W1, omega)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The instantaneous frequencies and damping ratios are also plotted","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"That, Rhat_r, rho, gamma = MAPFrequencyDamping(MFW, XFWoWdoWn, MSn, XSn, dispMaxAmp / dataScale)\nr_data = range(0, dispMaxAmp / dataScale, length=1000)\ndataFreq = abs.(That.(r_data)) / Tstep\ndataDamp = -log.(abs.(Rhat_r.(r_data))) ./ abs.(That.(r_data))\ndataAmp = r_data .* dataScale\n# plotting\nlines!(axFreq, dataFreq, dataAmp, label=\"DATA O($(R_order), $(S_order))\", linestyle=:solid, linewidth=2)\nlines!(axDamp, dataDamp, dataAmp, label=\"DATA O($(R_order), $(S_order))\", linestyle=:solid, linewidth=2)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"#Error-Analysis","page":"Invariant Models","title":"Error Analysis","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"To make sense of the results, we analyse the fitting error, which is the residual of the invariance equation divided by the distance from the invariant torus","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"    E = fracleft boldsymbolRleft(boldsymbolUleft(boldsymbolx_ktheta_kright)theta_kright) - boldsymbolUleft(boldsymboly_ktheta_k +omegaright) rightleft boldsymbolx_k - K(theta_k) right","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The amplitude of a given point is calculated by","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"    A = left boldsymbolW(boldsymbolU(boldsymbolx_k theta_k)) right","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The following call calculates A as OnManifoldAmplitude and various statistics about E as a function of the amplitude.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"OnManifoldAmplitude, hsU, errMaxX, errMaxY, errMinX, errMinY, errMeanX, errMeanY, errStdX = ErrorStatistics(MCF, XCF, MW, XW, thetaTX, dataTX, thetaTY, dataTY; dataScale=dataScale, cache=XCFcache)\nden = Makie.KernelDensity.kde(sort(vcat(OnManifoldAmplitude, -OnManifoldAmplitude)))\natol = eps(maximum(den.density))\nden.density[findall(isapprox.(den.density, 0, atol=atol))] .= atol\ndataDensityX = den.density\ndataDensityY = den.x","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"The error and data distribution is the plotted","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"axErr = Axis(fig[1, 2], xscale=log10)\naxDense = Axis(fig[1, 1], xscale=log10)\nxlims!(axErr, 1e-6, 1e-1)\nylims!(axErr, 0, maxAmp)\nxlims!(axDense, 1e-2, 100)\nylims!(axDense, 0, maxAmp)\n\nlines!(axDense, dataDensityX, dataDensityY)\nheatmap!(axErr, hsU, colormap=GLMakie.Reverse(:greys))\nlines!(axErr, errMaxX, errMaxY, linestyle=:solid, linewidth=2, color=:red)\nlines!(axErr, errMinX, errMinY, linestyle=:solid, linewidth=2, color=:red)\nlines!(axErr, errMeanX, errMeanY, linestyle=:dash, linewidth=2, color=:blue)\nlines!(axErr, errMeanX .+ errStdX, errMeanY, linestyle=:dot, linewidth=2, color=:green)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Finally plot legends are displayed","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"# creating the legend\nfig[1, 5] = Legend(fig, axFreq, merge=true, unique=true, labelsize=16, backgroundcolor=(:white, 0), framevisible=false, rowgap=1)\nresize_to_layout!(fig)\ndisplay(fig)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"(Image: )","category":"page"},{"location":"#Functional-Representation","page":"Invariant Models","title":"Functional Representation","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"All data structures follow the conventions of ManifoldsBase.jl. For example, the representation of the submersion boldsymbolU is given as two components MU and XU, where MU describes the function and XU contains the parameters of boldsymbolU.","category":"page"},{"location":"#Interpolation-in-Fourier-Space","page":"Invariant Models","title":"Interpolation in Fourier Space","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"When representing periodic functions, we use Fourier collocation. The grid of the collocation is given by","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"vartheta_1=0ldotsvartheta_2ell+1=frac2ell2ell+12pi","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"where ell is the highest resolved Fourier harmonic. The grid has 2ell+1 nodes, which is the same as the number of Fourier coefficients that can uniquely represent a periodic function on the grid.","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Given a set of points on the grid boldsymbolx_j=boldsymbolxleft(vartheta_jright), we can use an interpolation to reconstruct the periodic function on the interval 02pi) using","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymbolxleft(thetaright)=sum_j=1^2ell+1gammaleft(theta-vartheta_jright)boldsymbolx_j","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"where ","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"gammaleft(thetaright)=frac12ell+1fracsinfrac2ell+12thetasinfrac12theta","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Let us define the matrix boldsymbolX = (boldsymbolx_j ldots boldsymbolx_2ell+1)  and the interpolation vector for a given value of theta by","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymbolt_theta = (gammaleft(theta-vartheta_1right) ldots gammaleft(theta-vartheta_2ell+1right))^T","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"then the function evaluation boldsymbolxleft(thetaright) is a matrix-vector product","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymbolxleft(thetaright)= boldsymbolX boldsymbolt_theta","category":"page"},{"location":"#Input-to-Data-driven-Methods","page":"Invariant Models","title":"Input to Data-driven Methods","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"We assume that the data is produced by an unknown map boldsymbolF, such that ","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"boldsymboly_k = boldsymbolFleft(boldsymbolx_ktheta_kright)","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"When considering trajectories for some set of consecutive indices we have boldsymbolx_k+1=boldsymboly_k.  The data we analyse is organised into matrices","category":"page"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"beginaligned\nboldsymbolX = (boldsymbolx_1ldots boldsymbolx_N) \nboldsymbolY = (boldsymboly_1ldots boldsymbolx_N) \nboldsymbolTheta_x = (boldsymbolt_theta_1ldots boldsymbolt_theta_N) \nboldsymbolTheta_y = (boldsymbolt_theta_1+omegaldots boldsymbolt_theta_N + omega)\nendaligned","category":"page"},{"location":"#API-Reference","page":"Invariant Models","title":"API Reference","text":"","category":"section"},{"location":"#Finding-a-Linear-Model-from-Data","page":"Invariant Models","title":"Finding a Linear Model from Data","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"findLinearModel","category":"page"},{"location":"#InvariantModels.findLinearModel","page":"Invariant Models","title":"InvariantModels.findLinearModel","text":"findLinearModel(dataX, thetaX, dataY, thetaY, omega; ratio=0.5, steps=3)\n\nThe input arguments arguments\n\ndataX is matrix boldsymbolX. Each column corresponts to a data point.\ndataY is matrix boldsymbolY.\nthetaX is matrix boldsymbolTheta_x\nthetaY is matrix boldsymbolTheta_y\nratio the ratio of data to be kept at the final step\nsteps the number of steps to take to find \n\nFinds a linear model in the form of\n\nbeginaligned\nboldsymbolx_k+1 = boldsymbolA(theta_k) boldsymbolx_k + boldsymbolb(theta_k) \ntheta_k+1 = theta_k + omega\nendaligned\n\nand calculates the invariant torus represented by boldsymbolK from the equation\n\nboldsymbolK(theta+omega) = boldsymbolA(theta) boldsymbolK(theta) + boldsymbolb(theta)\n\nThe output is \n\nA, b, MK, XK\n\nA is a 3-index array representing boldsymbolA(theta)\nb is a 2-index array representing boldsymbolb(theta)\nMK, XK represent to torus parametrisation K\n\n\n\n\n\n","category":"function"},{"location":"#Data-Structures-and-Related-Functions","page":"Invariant Models","title":"Data Structures and Related Functions","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"getgrid","category":"page"},{"location":"#InvariantModels.getgrid","page":"Invariant Models","title":"InvariantModels.getgrid","text":"getgrid(n::Integer)\n\nReturns a uniform grid on the interval 0 2 pi) with 2n + 1 number of points. The end point 2pi is not part of the grid.\n\nThe number n corresponds to the number of Fourier harmonics that can be represented on the grid.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPConstant","category":"page"},{"location":"#InvariantModels.QPConstant","page":"Invariant Models","title":"InvariantModels.QPConstant","text":"M = QPConstant(dim_out, fourier_order, field::AbstractNumbers=ℝ)\n\nCreates a vector valued periodic function with fourier_order Fourier harmonics. The parameters are\n\ndim_out number of dimensions,\nfourier_order number of Fourier harmonics,\nfield whether it is real valued field=ℝ or complex valued field=ℂ.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPPolynomial","category":"page"},{"location":"#InvariantModels.QPPolynomial","page":"Invariant Models","title":"InvariantModels.QPPolynomial","text":"M = QPPolynomial(dim_out, dim_in, fourier_order, min_polyorder, max_polyorder, field::AbstractNumbers=ℝ; perp_idx=1:dim_in)\n\nCreates a vector valued polynomial that also a periodic function of another variable.\n\n    boldsymboly = P(boldsymbolx theta)\n\nThe parameters are\n\ndim_out number of output dimensions, i.e., the dimensionality of boldsymboly\ndim_in number independent variables, i.e., the dimensionality of boldsymbolx\nfourier_order number of Fourier harmonics for the independent variable theta\nmin_polyorder the lowest monomial order contained in polynomial P\nmax_polyorder the highest monomial order contained in polynomial P\nfield whether it is real valued field=ℝ or complex valued field=ℂ\nperp_idx the indices of idependent variables in boldsymbolx that must appear at least linearly in each monomial.  For example if we have 4 variables and perp_idx = [1 2], the monomial x_3 x_4 is not part of the polynomial, because they do not contains any of x_1 or x_2. However, x_1 x_3 is part of the polynomial, because 1 is among the indices given by perp_idx.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"fromFunction!","category":"page"},{"location":"#InvariantModels.fromFunction!","page":"Invariant Models","title":"InvariantModels.fromFunction!","text":"fromFunction!(M::QPPolynomial, W, fun)\n\nTaylor expands Julia function fun to a polynomial QPPolynomial, whose structure is prescribed by M. Function f = fun must have two arguments\n\n    f  mathbbR^n times 02pi) to mathbbR^m\n\nwhere n is dim_in and m is the dim_out parameter of polynomial M. The result is copied into W.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"fromFunction","category":"page"},{"location":"#InvariantModels.fromFunction","page":"Invariant Models","title":"InvariantModels.fromFunction","text":"W = fromFunction(M::QPPolynomial, fun)\n\nSame as fromFunction!, except that the result is returned in W.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Eval","category":"page"},{"location":"#InvariantModels.Eval","page":"Invariant Models","title":"InvariantModels.Eval","text":"res = Eval(M::QPPolynomial, X, theta::Matrix, data::Matrix; cache=makeCache(M, X, theta, data))\n\nSame as Eval!, except that the result is returned in res. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Eval!","category":"page"},{"location":"#InvariantModels.Eval!","page":"Invariant Models","title":"InvariantModels.Eval!","text":"Eval!(res, M::QPPolynomial, X, theta::Matrix, data::Matrix; cache=makeCache(M, X, theta, data))\n\nEvaluate the polynomial M, X at multiple data points. The data points are given by theta and data. Each column of theta and data corresponds to a single data point. The result is copied into res.\n\nThe matrix theta contains the interpolation weights of Fourier collocation and not the actual values of theta. Generally, these interpolation weights are pre-calculated, which avoids repeated calculation. The number of rows of theta is the same as 2 n + 1, where n is the number of Fourier modes resolved by polynomial M.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"mapFromODE","category":"page"},{"location":"#InvariantModels.mapFromODE","page":"Invariant Models","title":"InvariantModels.mapFromODE","text":"mapFromODE(M::QPPolynomial, W, fun, par, omega, dt, step)\n\nCreates a Poincare map from the vector field given by fun and places it into the polynomial M, X. The parameters are\n\nM ,W the polynomial to contain the result.\nfun the vector field in the form of fun(dx, x, p, theta), where x is the input state var, dx is the time-derivative fracmathrmdboldsymbolxmathrmdt, p is the parameter, which equals to par and theta is the phase of forcing on the interval 0 2pi).\npar is the parameter (vector) of fun.\nomega is the forcing frequency. The independent variable t of fun is calculated as theta = omega t, where t is the independent variable (time).\ndt is the time step of the integrator.\nstep is time period that the differential equation is solved for.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"toFourier","category":"page"},{"location":"#InvariantModels.toFourier","page":"Invariant Models","title":"InvariantModels.toFourier","text":"MF, XF = toFourier(M::QPPolynomial, X)\n\nConverts the polynomial M, X to another polynomial that contains Fourier coefficients as opposed to collocated values of the polynomial.\n\n\n\n\n\n","category":"function"},{"location":"#Semi-analytic-Reduction-to-Invariant-Manifolds","page":"Invariant Models","title":"Semi-analytic Reduction to Invariant Manifolds","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPMAPTorusManifold","category":"page"},{"location":"#InvariantModels.QPMAPTorusManifold","page":"Invariant Models","title":"InvariantModels.QPMAPTorusManifold","text":"QPMAPTorusManifold(MP::QPPolynomial, XP, omega, SEL; \n                        threshold = 0.1, \n                        resonance = false, \n                        rom_order = max_polyorder)\n\nThe inputs are the following\n\nMP, XP the Poincare map that describes the dynamics.\nomega the phase shift at each time-step\nSEL which spectral bundles to use for the calculation of the invariant manifold\nthreshold if a near resonance is greater than this value, it is ignored\nresonance: when false the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.\nrom_order what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map MP, XP.\n\nThis function does three calculations\n\nCalculates the invariant torus using Newton's method. The startnig iteration is at the origin.\nCalculates the linear system about the invariant torues and decomposes it into invariant vector bundles. The bundles are ordered by the corresponding spectrum. The bundles with the greatest spectral radius appear first.\nGiven the invariant bundles about the torus, calculate the invariant manifold tangent to the selected vector bundles. The selection is done by SEL.\n\nReturn values are:\n\nMK, XK, MSn, XSn, MWn, XWn, MSd, XSd, XWre\n\nMK, XK represent the invariant torus\nMSn, XSn the normal form of the conjugate dynamics on the invariant manifold\nMWn, XWn the manifold immersion in the coordinate system of the invariant vector bundle, selected by SEL\nMSd, XSd the full system MP, XP transformed to the coordinate system of the vector bundle decomposition\nXWre the transformation from the vector bundles to the original coordinate system\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPODETorusManifold","category":"page"},{"location":"#InvariantModels.QPODETorusManifold","page":"Invariant Models","title":"InvariantModels.QPODETorusManifold","text":"QPODETorusManifold(MP::QPPolynomial, XP, omega, SEL; \n                        threshold = 0.1, \n                        resonance = false, \n                        rom_order = max_polyorder)\n\nThis is the equivalent version of QPMAPTorusManifold for vector fields.\n\nThe inputs are the following\n\nMP, XP the vector field that describes the dynamics.\nomega is the forcing frequency\nSEL which spectral bundles to use for the calculation of the invariant manifold\nthreshold if a near resonance is greater than this value, it is ignored\nresonance: when false the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.\nrom_order what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map MP, XP.\n\nThis function does three calculations\n\nCalculates the invariant torus using Newton's method. The startnig iteration is at the origin.\nCalculates the linear system about the invariant torues and decomposes it into invariant vector bundles. The bundles are ordered by the corresponding spectrum. The bundles with the greatest spectral radius appear first.\nGiven the invariant bundles about the torus, calculate the invariant manifold tangent to the selected vector bundles. The selection is done by SEL.\n\nReturn values are:\n\nMK, XK, MSn, XSn, MWn, XWn, MSd, XSd, XWre, Lambda\n\nMK, XK represent the invariant torus\nMSn, XSn the normal form of the conjugate dynamics on the invariant manifold\nMWn, XWn the manifold immersion in the coordinate system of the invariant vector bundle, selected by SEL\nMSd, XSd the full system MP, XP transformed to the coordinate system of the vector bundle decomposition\nXWre the transformation from the vector bundles to the original coordinate system\nLambda is the linear part of the system about the invariant torus in the coordinate system of the vector bundles. This is for debug purposes only, it should be a diagonal matrix for each collocation point.\n\n\n\n\n\n","category":"function"},{"location":"#Manifolds-via-Invariant-Foliations","page":"Invariant Models","title":"Manifolds via Invariant Foliations","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPGraphStyleFoliations","category":"page"},{"location":"#InvariantModels.QPGraphStyleFoliations","page":"Invariant Models","title":"InvariantModels.QPGraphStyleFoliations","text":"QPGraphStyleFoliations(MP::QPPolynomial, XP, omega, SEL; dataScale=1, resonance=false, threshold=0.1, rom_order=max_polyorder)\n\nThe purpose of this function is to calculate two complementary invariant foliations about an invariant torus and then extract the invariant manifold that is the zero level set of the second foliation. The invariant manifold has the same dynamics as the first foliation.\n\nThe inputs are the following\n\nMP, XP the Poincare map that describes the dynamics.\nomega the phase shift at each time-step\nSEL which spectral bundles to use for the calculation of the invariant manifold\ndataScale is the scaling factor that scales the coordinate system of the invariant manifold. This scaling is used when we would like to compare the invariant manifold identified from data that has been scaled. Using the same scaling factor makes this comparison possible.\nthreshold if a near resonance is greater than this value, it is ignored\nresonance: when false the conjugate map is reduced to an autonomous system, even if there are near resonances.    Otherwise all near resonances are accounted for in the conjugate map.\nrom_order what is the highest order for which near resonances are taken into account. It defaults to the order of the Poincare map MP, XP.\n\nReturn values are:\n\nMRf, XRf, MW, XW, MRt, XRt, MUV, XUVflat, MSt, XSt, MVU, XVUflat\n\nMRf, XRf the conjugate dynamics of the first invariant foliation (SEL) in normal form coordinates and with Fourier coefficients\nMW, XW the immersion of the invariant manifold in the original coordinate system\n\nThe outputs that could be used to set initial conditions to a foliation\n\nMRt, XRt the conjugate dynamics of the first invariant foliation (SEL) when the foliation is parametrised graph-style\nMUV, XUVflat\nMSt, XSt the conjugate dynamics of the second invariant foliation when the foliation is parametrised graph-style\nMVU, XVUflat\n\n\n\n\n\n","category":"function"},{"location":"#Frequencies-and-Damping-Ratios","page":"Invariant Models","title":"Frequencies and Damping Ratios","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"MAPFrequencyDamping","category":"page"},{"location":"#InvariantModels.MAPFrequencyDamping","page":"Invariant Models","title":"InvariantModels.MAPFrequencyDamping","text":"MAPFrequencyDamping(MW::QPFourierPolynomial, XW, MR::QPFourierPolynomial, XR, amp_max; output = Diagonal(I,dim_out))\n\nCalculates corrected frequencies and damping ratios for a centre type equilibrium. The inputs are\n\nMW, XW is the manifold immersion boldsymbolW mathbbR^2 times 02pi) to mathbbR^n\nMR, XR is the conjugate dynamics boldsymbolW mathbbR^2 times 02pi) to mathbbR^2\namp_max is the maximum amplitude to be considered\noutput is a matrix boldsymbolM that is used to calculate the instantaneous amplitude by pre multiplying the immersion: boldsymbolM boldsymbolW.\n\nThe inputs are such that they satisfy the invariance equation\n\nboldsymbolWleft(boldsymbolRleft(boldsymbolzthetaright)theta+omegaright)=boldsymbolFleft(boldsymbolWleft(boldsymbolzthetaright)thetaright)\n\nwhere boldsymbolF is the map of the original dynamics. Given that the invariant manifold is in a normal form, we have the following structure to the conjugate map\n\nboldsymbolRleft(boldsymbolzright)=beginpmatrixsleft(zoverlinezright)\noverlinesleft(zoverlinezright)\nendpmatrix\n\nUsing a the transformation z=rholeft(rright)expleft(ibeta+ialphacircrholeft(rright)right) we can write the manifold immersion as\n\nwidehatboldsymbolWleft(rbetathetaright)=boldsymbolWleft(rholeft(rright)expleft(ibeta+ialphacircrholeft(rright)right)rholeft(rright)expleft(-ibeta-ialphacircrholeft(rright)right)thetaright)\n\nso that the invariance equation holds\n\nwidehatboldsymbolWleft(Rleft(rright)beta+Tleft(rright)theta+omegaright)=boldsymbolFleft(widehatboldsymbolWleft(rbetathetaright)thetaright)\n\nwhere R and T are calculated using the same transformation.\n\nThe unknown functions rho and alpha are calculated such that \n\nthe amplitude of a tori as a function of r is the same as r and \nthere is zero phase shift between any two tori with different amplitudes with respect to parameter beta.\n\nReturn values are\n\nT, R_r, rho, alpha\n\nT is the function T  0infty) to mathbbR\nR_r is the function r mapsto R(r)  r\nrho is the same as rho\nalpha is the same as alpha\n\nThe instantaneous frequency is calculated as\n\nomega(r) = fracT(r)Delta t\n\nthe instantaneous damping is calculated as\n\nzeta(r) = -fraclog r^-1 R(r)T(r)\n\nwhere Delta t is the sampling period.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"ODEFrequencyDamping","category":"page"},{"location":"#InvariantModels.ODEFrequencyDamping","page":"Invariant Models","title":"InvariantModels.ODEFrequencyDamping","text":"ODEFrequencyDamping(MW::QPFourierPolynomial, XW, MR::QPFourierPolynomial, XR, amp_max; output = Diagonal(I,dim_out))\n\nThe inputs and outputs are the same as MAPFrequencyDamping, except that the interpretation of the input/output is slightly different. The input satisfies the invariance equation\n\nD_1boldsymbolWleft(boldsymbolzthetaright) boldsymbolRleft(boldsymbolzthetaright) + D_1boldsymbolWleft(boldsymbolzthetaright) omega = boldsymbolFleft(boldsymbolWleft(boldsymbolzthetaright)thetaright)\n\nwhere boldsymbolF is a vector field.\n\nFrom the output, the instantaneous frequency is \n\nomega(r) = T(r)\n\nthe instantaneous damping is calculated as\n\nzeta(r) = -fracr^-1 R(r)T(r)\n\n\n\n\n\n","category":"function"},{"location":"#Generating-Data","page":"Invariant Models","title":"Generating Data","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"generate","category":"page"},{"location":"#InvariantModels.generate","page":"Invariant Models","title":"InvariantModels.generate","text":"generate(NDIM, rhs!, maxIC, nruns, npoints, fourier_order, omega, Tstep, A, XWre)\n\nCreates a data set from a differential equation, represented by rhs!. An invariant torus is found by observing a convergent simulation to the torus. The initial conditions are sampled from an ellipsoid about the torus. The directions of the ellipsoid are given by the linear transformation XWre. For each column of XWre the maximum amplitude is specified by the corresponding element of the vector maxIC.\n\nThe input parameters are\n\nNDIM the dimensionality of the system\nrhs! the vector field in the form of fun(dx, x, p, theta), where x is the input state var, dx is the time-derivative fracmathrmdboldsymbolxmathrmdt, p is the parameter, which equals to par and theta is the phase of forcing on the interval 0 2pi).\nmaxIC is a vector of size NDIM, containing the maximum simulation amplitudes in each direction of XWre\nnruns the number of simulation runs\nnpoints the length of the trajectory for each simulation run\nfourier_order the number of Fourier harmonics to consider when calculating boldsymbolTheta_x, boldsymbolTheta_y\nomega the forcing frequency, as in dottheta = omega\nTstep the time step between two samples of the trajectory, denoted by Delta t\nA the parameter p of the vector field\nXWre is the transformation that defines the axes of the ellipsoid about the invariant torus\n\nThe function returns\n\ndataX, dataY, thetaX, thetaY, thetaNIX, thetaNIY\n\ndataX is matrix boldsymbolX. Each column corresponts to a data point.\ndataY is matrix boldsymbolY.\nthetaX is matrix boldsymbolTheta_x\nthetaY is matrix boldsymbolTheta_y\nthetaNIX is the vector (theta_1 ldots theta_N)\nthetaNIY is the vector (theta_1 + omega Delta t ldots theta_N + omega Delta t)\n\nspace\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"generateMap","category":"page"},{"location":"#InvariantModels.generateMap","page":"Invariant Models","title":"InvariantModels.generateMap","text":"generateMap(MF, XF, MK, XK, maxIC, nruns, npoints, fourier_order, omega, Tstep)\n\nSimilar to generate, except that it simulates a discrete-time system.\n\nThe inputs differ from generate. Instead of the vector field, the following must be specified\n\nMF, XF the discrete-time map of the system\nMK, XK the invariant torus arbout which the system is simulated.\n\nThere is no way the specify an ellipsoid for initial conditions, they are taken from a sphere of radius maxIC.\n\n\n\n\n\n","category":"function"},{"location":"#Identfying-Invariant-Foliations-from-Data","page":"Invariant Models","title":"Identfying Invariant Foliations from Data","text":"","category":"section"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPPreProcess","category":"page"},{"location":"#InvariantModels.QPPreProcess","page":"Invariant Models","title":"InvariantModels.QPPreProcess","text":"QPPreProcess(K, A, omega, thetaX, dataX, thetaY, dataY, sel; Tstep=1.0, maxAmp=Inf, data_ratio=1.0, preId=[])\n\nThis function is called after a linear model has been identified using findLinearModel. The following calculations are carried out\n\ndecompose the linear dynamics into invariant vector bundles.\nproject the data onto two invariant vector bundles, one that corresponds to the spectral circles selected by sel and the the remaining bundle. In this coordinate system the approximate linear model represented by A becomes block-diagonal.\n\n\nThe input arguments arguments\n\nK approximate invariant torus\nA approximate linear map about the torus\ndataX is matrix boldsymbolX. Each column corresponts to a data point.\ndataY is matrix boldsymbolY.\nthetaX is matrix boldsymbolTheta_x These are the interpolations vectors for Fourier collocation corresponding to theta_k.\nthetaY is matrix boldsymbolTheta_y\nsel indicates the selected vector bundles.\nTstep is the sampling period Delta t\nmaxAmp is the maximum amplitude of the data along the selected vector bundle\ndata_ratio in 01 the proportion of the data to be kept and the rest is removed so that it is uniformly distributed along in the neighbourhood of the selected vector bundles.\npreId if non-empty, this replaces the data filtering process.\n\nThe output is\n\nthetaTX, dataTX, thetaTY, dataTY, dataScale, id, R1, S1, W1\n\nthetaTX, dataTX, thetaTY, dataTY are the filtered and scaled data. The approximate invariant torus is subtracted and the data is transformed into the coordiante system of the approximate vector bundles calculated from A.\ndataScale is the scaling factor that relates the input and output dataX[:,id] = dataScale * dataTX.\nid the indices of the input that are brought to the output\nR1 is the invariant part of the the linear system A that is invariant under the selected sel vector bundles\nS1 is the invariant part of the the linear system A that is invariant under the not selected (setdiff(1:data_dim, sel)) vector bundles\nW1 the inverse transformation that brings that data back into the physical coordinate system.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPCombinedFoliation","category":"page"},{"location":"#InvariantModels.QPCombinedFoliation","page":"Invariant Models","title":"InvariantModels.QPCombinedFoliation","text":"QPCombinedFoliation(dim_data, dim_latent, fourier_order, R_order, U_order, S_order, V_order, R1, S1, MK, XK; sparse=false)\n\nCreates the data structures to store a pair of foliations that might be interconnected through scaling. The invariance equations represented by a Combined Foliation are\n\nbeginaligned\nboldsymbolRleft(boldsymbolUleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolUleft(boldsymbolFleft(boldsymbolxboldsymbolthetaright)boldsymboltheta+boldsymbolomegaright)\nboldsymbolSleft(boldsymbolVleft(boldsymbolxboldsymbolthetaright)boldsymbolthetaright) = boldsymbolVleft(boldsymbolFleft(boldsymbolxboldsymbolthetaright)boldsymboltheta+boldsymbolomegaright)\nendaligned\n\nThe input parameters are\n\ndim_data system dimension\ndim_latent the dimension of the reduced order model\nfourier_ordernumber of Fourier harmonics used in discretisation\nR_order the polynomial order of function boldsymbolR\nU_order the polynomial order of function boldsymbolU\nS_order the polynomial order of function boldsymbolS\nV_order the polynomial order of function boldsymbolV\nR1 the initial linear part of function boldsymbolR\nS1 the initial linear part of function boldsymbolS\nMK, XK the invariant torus\nsparse use compressed polynomials (default = false)\n\nThe output is the data structure\n\nMCF, XCF\n\n\n\n\n\n","category":"type"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"makeCache","category":"page"},{"location":"#InvariantModels.makeCache","page":"Invariant Models","title":"InvariantModels.makeCache","text":"makeCache(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY)\n\nCreates a cache object for a combined foliation. The cache stores intermediate results that are not re-calculated between various steps of the optimisation. This improves performance significantly.\n\nInput:\n\nM, X the combined foliation generated by QPCombinedFoliation\ndataTX is matrix boldsymbolX. Each column corresponds to a data point.\ndataTY is matrix boldsymbolY.\nthetaX is matrix boldsymbolTheta_x These are the interpolations vectors for Fourier collocation corresponding to theta_k.\nthetaY is matrix boldsymbolTheta_y\n\nThe output is a cache object cache.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"updateCache!","category":"page"},{"location":"#InvariantModels.updateCache!","page":"Invariant Models","title":"InvariantModels.updateCache!","text":"updateCache!(cache::FCache, M, X, thetaX, dataTX, thetaY, dataTY)\n\nThe same argument as makeCache, expect that it updates cache.\n\n\n\n\n\nupdateCache!(cache::FCache, M, X, thetaX, dataTX, thetaY, dataTY, sel)\n\nThe same input argument as makeCache, expect that it updates cache only for the component of the foliation given by sel.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPOptimise","category":"page"},{"location":"#InvariantModels.QPOptimise","page":"Invariant Models","title":"InvariantModels.QPOptimise","text":"QPOptimise(MCF::QPCombinedFoliation, XCF, thetaTX, dataTX, thetaTY, dataTY;\n    maxit=24, \n    gradient_ratio=2^(-7), gradient_stop=2^(-29), \n    steps=400, \n    name=\"default\",\n    cache=makeCache(MCF, XCF, thetaTX, dataTX, thetaTY, dataTY),\n    omega=1.0, Tstep=1.0, dataScale=1.0, dataId=1:size(thetaTX, 2), radii=to_zero(XCF), skipRS=false)\n\nUse optimisation to fit the parameters of the combined foliation to data.\n\nInput parameters are\n\nMCF, XCF the combined foliation\nthetaTX, dataTX, thetaTY, dataTY the data\nmaxit maximum number of iterations within one trust-regions subproblem solution\ngradient_ratio the subproblem solution stops once the norm of the gradient is reduced by this factor\ngradient_stop the subproblem solution stops when the norm of the gradient is below this value\nsteps the number of subproblem solutions as we iterate over the components of the combined foliation\nname the name of the problem, used for logging purposes\ncache is created by makeCache\nomega the forcing shift-angle\nTstep the sampling period of the data Delta t\ndataScale the scaling factor used to scale the data\ndataId the indices of the data points from the original data set\nradii initial trust-regions radii for each component of the combined foliation\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPPostProcess","category":"page"},{"location":"#InvariantModels.QPPostProcess","page":"Invariant Models","title":"InvariantModels.QPPostProcess","text":"QPPostProcess(MCF::QPCombinedFoliation, XCF, omega, resonance=false, threshold=0.1)\n\nExtracts the invariant manifold from the combined foliation together with its dynamics. The result is in a normal form with mixed power series Fourier series form.\n\nParamaters:\n\nMCF, XCF the combined foliation.\nW1 the inverse trabsformation produced by QPPreProcess\nomega the forcing shift-angle.\nresonance true if to account for non-autonomous internal resonances. When false, the result will be an autonomous normal form.\nthreshold if the distance between the two side of the non-resonance criterion is less than threshold, it counts as an internal (or external) resonance\n\nReturns:\n\nMSn, XSn, MFW, XFWoWdoWn, MW, XW\n\nMSn, XSn the conjugate dynamics on the manifold in normal form\nMFW, XFWoWdoWn manifold immersion in the physical coordinate system and adapted to correspond to the normal form\nMW, XW manifold immersion in the coordinate system of the combined foliation (not physical coordinates)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"EvalU","category":"page"},{"location":"#InvariantModels.EvalU","page":"Invariant Models","title":"InvariantModels.EvalU","text":"EvalU(M::QPCombinedFoliation, X, thetaX, dataTX; cache)\n\nEvaluates the submersion boldsymbolU at data points thetaX, dataTX.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"EvalV","category":"page"},{"location":"#InvariantModels.EvalV","page":"Invariant Models","title":"InvariantModels.EvalV","text":"EvalV(M::QPCombinedFoliation, X, thetaX, dataTX; cache)\n\nEvaluates the submersion boldsymbolV at data points thetaX, dataTX.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"Loss","category":"page"},{"location":"#InvariantModels.Loss","page":"Invariant Models","title":"InvariantModels.Loss","text":"Loss(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)\n\nReturns the loss function of the combined foliation M, X at data points thetaX, dataTX, thetaY, dataTY.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"ResidualU","category":"page"},{"location":"#InvariantModels.ResidualU","page":"Invariant Models","title":"InvariantModels.ResidualU","text":"ResidualU(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)\n\nReturns the residual of the invariance equation for boldsymbolU divided by the norm of boldsymbolV.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"ResidualLoss","category":"page"},{"location":"#InvariantModels.ResidualLoss","page":"Invariant Models","title":"InvariantModels.ResidualLoss","text":"ResidualLoss(M::QPCombinedFoliation, X, thetaX, dataTX, thetaY, dataTY; cache)\n\nReturns the loss function only for the component with boldsymbolU of the combined foliation M, X at data points thetaX, dataTX, thetaY, dataTY.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"QPKernel","category":"page"},{"location":"#InvariantModels.QPKernel","page":"Invariant Models","title":"InvariantModels.QPKernel","text":"QPKernel(MF::QPCombinedFoliation, XF)\n\nReturns the root of the combined foliation in the form of MK, XK, which is the same as the invariant torus.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"copyMost!","category":"page"},{"location":"#InvariantModels.copyMost!","page":"Invariant Models","title":"InvariantModels.copyMost!","text":"copyMost!(MCFD::QPCombinedFoliation, XCFD, MCFS::QPCombinedFoliation, XCFS)\n\nMake a best-effort attempt to copy the combined foliation MCFS, XCFS into MCFD, XCFD.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"SetTorus!","category":"page"},{"location":"#InvariantModels.SetTorus!","page":"Invariant Models","title":"InvariantModels.SetTorus!","text":"SetTorus!(MCF::QPCombinedFoliation, MK::QPConstant, XK)\n\nSet the location of the torus MK, XK for the combined foliation MCF.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"bincuts","category":"page"},{"location":"#InvariantModels.bincuts","page":"Invariant Models","title":"InvariantModels.bincuts","text":"bincuts(long_amp, trans_amps, max_amp, max_points, nbins; exponent=1)\n\nThis function is used to filter out data points that are far from an invariant manifold. \n\nlong_amps vector of amplitudes along the invariant manifold\ntrans_amps vector of distances from the invariant manifold\nmax_amp discard points that have greater amplitude than max_amp\nmax_points the maximum number of points to return\nnbins the number of bins along which the distribution is made uniform\nexponent used to calculate bin sizes. The bins fall between the nodes of range(0, max_amp, length=nbins + 1) .^ exponent.\n\nReturns the indices of long_amps that create a uniform distribution with respect to the bins and only contain the smallest trans_amps values from those bins.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Invariant Models","title":"Invariant Models","text":"to_zero","category":"page"},{"location":"#InvariantModels.to_zero","page":"Invariant Models","title":"InvariantModels.to_zero","text":"to_zero(x::ArrayPartition)\n\nCreates an ArrayPartition the same structure as x expect that each component is a single element array with zero value.\n\n\n\n\n\n","category":"function"}]
}
